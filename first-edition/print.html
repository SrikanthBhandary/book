<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>intermezzOS</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="background.html"><strong aria-hidden="true">1.</strong> Background</a></li><li><ol class="section"><li><a href="what.html"><strong aria-hidden="true">1.1.</strong> What is an OS?</a></li><li><a href="what-kind-is-there.html"><strong aria-hidden="true">1.2.</strong> What kinds of OS are there?</a></li><li><a href="what-kind-are-we-making.html"><strong aria-hidden="true">1.3.</strong> What kind are we making?</a></li><li><a href="tools.html"><strong aria-hidden="true">1.4.</strong> What tools will we use?</a></li></ol></li><li><a href="setup.html"><strong aria-hidden="true">2.</strong> Setting up a development environment</a></li><li><ol class="section"><li><a href="installing-rust.html"><strong aria-hidden="true">2.1.</strong> Installing Rust</a></li><li><a href="linux.html"><strong aria-hidden="true">2.2.</strong> Linux</a></li><li><a href="osx.html"><strong aria-hidden="true">2.3.</strong> Mac OS X</a></li><li><a href="windows.html"><strong aria-hidden="true">2.4.</strong> Windows</a></li></ol></li><li><a href="booting-up.html"><strong aria-hidden="true">3.</strong> Booting up</a></li><li><ol class="section"><li><a href="multiboot-headers.html"><strong aria-hidden="true">3.1.</strong> Multiboot headers</a></li><li><a href="hello-world.html"><strong aria-hidden="true">3.2.</strong> Hello, world!</a></li><li><a href="making-an-iso.html"><strong aria-hidden="true">3.3.</strong> Making an ISO</a></li><li><a href="running-in-qemu.html"><strong aria-hidden="true">3.4.</strong> Running in QEMU</a></li><li><a href="automation-with-make.html"><strong aria-hidden="true">3.5.</strong> Automation with Make</a></li></ol></li><li><a href="transitioning-to-long-mode.html"><strong aria-hidden="true">4.</strong> Transitioning to Long Mode</a></li><li><ol class="section"><li><a href="paging.html"><strong aria-hidden="true">4.1.</strong> Paging</a></li><li><a href="setting-up-a-gdt.html"><strong aria-hidden="true">4.2.</strong> Setting up a GDT</a></li><li><a href="jumping-headlong-into-long-mode.html"><strong aria-hidden="true">4.3.</strong> Jumping headlong into long mode</a></li></ol></li><li><a href="a-rust-kmain.html"><strong aria-hidden="true">5.</strong> A Rust kmain()</a></li><li><ol class="section"><li><a href="creating-our-first-crate.html"><strong aria-hidden="true">5.1.</strong> Creating our first crate</a></li><li><a href="hello-from-rust.html"><strong aria-hidden="true">5.2.</strong> Hello from Rust!</a></li><li class="spacer"></li></ol></li><li><a href="appendix/troubleshooting.html">Appendix A: Troubleshooting</a></li><li class="affix"><a href="appendix/numeral-systems.html">Appendix B: Numeral Systems</a></li><li class="affix"><a href="appendix/osx-install.html">Appendix C: Mac OS X Install Script</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">intermezzOS</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 class="center">intermezzOS</h1>
<img class="center" src="rhizome.jpg" alt="rhizome" />
<p class="center">An operating system for learning</p>
<h2><a class="header" href="#preface" id="preface">Preface</a></h2>
<p>This book describes the intermezzOS project. intermezzOS is a hobby operating
system, specifically targeted at showing beginners how to get into operating
systems development. Rather than describe some sort of final OS, it instead
proceeds in a tutorial-like fashion, allowing you to implement intermezzOS
yourself, alongside the book.</p>
<p>The book assumes that you have programmed in some language before, but not any
particular one. In fact, people who have not done low-level programming before
are a specific target of this book; I’ll be explaining a lot of things that
other resources will just assume that you know.</p>
<p>intermezzOS is implemented in <a href="https://www.rust-lang.org/">Rust</a>, and some
assembly code. We’ll try to explain Rust along the way, but may refer you to
its documentation when things get tricky. This book isn’t <em>really</em> about
learning Rust, but you might accidentally along the way.</p>
<p>You can find all of this stuff <a href="https://github.com/intermezzOS/">on GitHub</a>.
This book is in the <code>book</code> repository, the kernel is in <code>kernel</code>, and the
website is there too. Feel free to open issues on the <a href="https://github.com/intermezzOS/rfcs">RFCs
repo</a> if you want to discuss things
in a general sense, and send bug reports and PRs to the appropriate repos
if you’d like to help with a particular component.</p>
<h2><a class="header" href="#the-story" id="the-story">The Story</a></h2>
<p>A long time ago, in college, my friends and I were working on a hobby operating
system, <a href="http://xomb.org">XOmB</a>. It was... tough. Frankly, while I learned a
lot, I was a pretty minor contributor. I got frustrated too easily. One day, I
found Ruby, and I was pretty much done with low-level programming. I had done
it most of my life, and I was bored. Bored, and sick of dealing with core
dumps.</p>
<p>Those details aren’t that important. What is important is that over the years,
I’ve always wanted to get back into this stuff. But the problem is this: there
are a lot of people who do hobby operating system work, but... I don’t like
their attitudes.</p>
<p>You see, a lot of people see low-level programming as some kind of superior,
only-for-the-smartest kind of thing. They have a puritanical world-view: “I
suffered to learn this, so you too must suffer to build character.” I think
that’s short sighted. Low level programming <em>is</em> difficult to get into, but
that says more about the teachers’ faults than the students’.</p>
<p>Anyway, as my professional life has moved back towards the low level, I’ve been
thinking about this topic a lot again. That’s when I found an awesome link:
<a href="http://os.phil-opp.com/multiboot-kernel.html">Writing an OS in Rust by Philipp Oppermann</a>. I cannot speak enough
about how awesome Phil’s tutorial is; it single-handedly inspired me to get
back into operating systems.</p>
<p>The big difference with Phil’s tutorial is that it doesn’t treat you as being
stupid for not knowing ‘the basics’. It doesn’t say “spend hours debugging this
thing, because I did.” It doesn’t insult you for being new. It just explains
the basics of a kernel.</p>
<p>It’s amazing how much a little bit of a framing can completely change the way
you see something. When the examples I found were all about how you have to be
an amazing rockstar ninja and we won’t give you all the code because you suck
if you can’t figure it out, I hated this stuff. When it was kind,
understanding, and helpful, I couldn’t get enough.</p>
<p>Once I got to a certain part in Phil’s tutorial, I started implementing stuff
myself. A lot of the initial code here is going to be similar to Phil’s.
But I’m going to write about it anyway. There’s a good reason for that:</p>
<blockquote>
<p>Writing is nature’s way of showing us how sloppy our thinking is.</p>
<ul>
<li>Leslie Lamport</li>
</ul>
</blockquote>
<p>By re-explaining things in my own words, I hope to understand it even better.
This is just a perpetual theme with me: I like teaching because it helps me
learn. I like writing because it helps me understand.</p>
<p>The first section of the book is going to be clear about where we’re following
Phil, and where we break off and go into our own little world. After the start,
things will end up diverging.</p>
<p>Furthermore, I will not commit to any kind of schedule for this project. It’s
going to be in my spare time, and I’m learning a lot of this as I go, too.</p>
<h2><a class="header" href="#the-name" id="the-name">The Name</a></h2>
<blockquote>
<p>The nomad has a territory; he follows customary paths; he goes from one point
to another; he is not ignorant of points (water points, dwelling points,
assembly points, etc.). But the question is what in nomad life is a principle
and what is only a consequence. To begin with, although the points determine
paths, they are strictly subordinated to the paths they determine, the
reverse happens with the sedentary. The water point is reached only in order
to be left behind; every point is a relay and exists only as a relay. A path
is always between two points, but the in-between has taken on all the
consistency and enjoys both an autonomy and a direction of its own. The life
of the nomad is the intermezzo.</p>
<p>Deleuze and Guattari, “A Thousand Plateaus”, p380</p>
</blockquote>
<p>If you’re not into particular kinds of philosophy, this quote won’t mean a lot.
Let’s look at the dictionary definition:</p>
<blockquote>
<p>An intermezzo, in the most general sense, is a composition which fits between
other musical or dramatic entities, such as acts of a play or movements of a
larger musical work.</p>
<p><a href="https://en.wikipedia.org/wiki/Intermezzo">https://en.wikipedia.org/wiki/Intermezzo</a></p>
</blockquote>
<p>I want this project to be about learning. Learning is often referred to as a
journey. You start off in ignorance and end in knowledge. In other words,
‘learning’ is that part in the middle, the in-between state.</p>
<p>The tricky thing about learning is, you never stop learning. Once you learn
something, there’s something new to learn, and you’re on a journey again.</p>
<p>If you want to learn a lot, then you’ll find yourself perpetually in the
middle.</p>
<p>There is another sense by which this name makes sense: as we’ll learn in the
beginning of the book, operating systems are largely about abstractions. And
abstractions are themselves ‘in the middle’, between what they’re abstracting
and who they are abstracting it for.</p>
<h2><a class="header" href="#principles" id="principles">Principles</a></h2>
<p>Here are the guiding principles of intermezzOS:</p>
<ul>
<li>We’re all actual people. Please treat each other as such.</li>
<li>We’re all here to learn. Let’s help each other learn, rather than being some
kind of vanguard of knowledge.</li>
<li>The only thing that matters about your language background is the amount you
may have to learn.</li>
<li>Everything must be documented, or it’s not done.</li>
</ul>
<p>And of course, everything related to this project is under the <a href="http://intermezzos.github.io/code-of-conduct.html">Code of
Conduct</a>.</p>
<h1><a class="header" href="#background" id="background">Background</a></h1>
<p>Before we get going, we should probably have some idea of where we’re headed.</p>
<h1><a class="header" href="#what-is-an-os" id="what-is-an-os">What is an OS?</a></h1>
<p>It’s actually kind of difficult to define what an operating system is. There
are a lot of different kinds of operating systems, and they all do different
kinds of things.</p>
<p>Some things are commonly bundled with operating systems, but are arguably not
part of the essence of what makes an OS an OS. For example, many operating
systems are often marketed as coming equipped with a web browser or email
client. Are web browsers and email clients essential to operating systems?
Many would argue the answer is no.</p>
<p>There are some shared goals we can find among all operating systems, however.
Let’s try this out as a working definition:</p>
<blockquote>
<p>An operating system is a program that provides a platform for other
programs. It provides two things to these programs: abstractions and
isolation.</p>
</blockquote>
<p>This is good enough for now. Let’s consider this a test for inclusion,
but not exclusion. In other words, things that fit this definition
<em>are</em> operating systems, but things that don’t may or may not be,
we don’t quite know.</p>
<h2><a class="header" href="#creating-abstractions" id="creating-abstractions">Creating abstractions</a></h2>
<p>There are many reasons to create a platform for other programs, but a
common one for operating systems is to abstract over hardware.</p>
<p>Consider a program, running on some hardware:</p>
<img alt="program on hardware" class="center" src="assets/program_hardware.png" />
<p>This program will need to know <em>exactly</em> about what kind of hardware exists.
If you want to run it on a different computer, it will have to know exactly
about that computer too. And if you want to write a second program, you’ll
have to re-write a bunch of code for interacting with the hardware.</p>
<blockquote>
<p>All problems in computer science can be solved by another level of
indirection.</p>
<ul>
<li>David Wheeler</li>
</ul>
</blockquote>
<p>To solve this problem, we can introduce an abstraction:</p>
<img alt="program on os on hardware" class="center" src="assets/program_os_hardware.png" />
<p>Now, the operating system can handle the details of the hardware, and provide
an API for it. A program can be written for that operating system’s API, and
can then run on any hardware that the operating system supports.</p>
<p>At some point, though, we developed many operating systems. Since operating
systems are platforms, most people pick one and have only that one on their
computer. So now we have a problem that looks the same, but is a bit
different: our program is now specific to an OS, rather than specific to
a particular bit of hardware.</p>
<p>To solve this, some programming languages have a ‘virtual machine.’ This
was a big selling point of Java, for example: the Java Virtual Machine.
The idea here is that we create a <em>virtual</em> machine on top of the <em>real</em>
machine.</p>
<img alt="program on vm " class="center" src="assets/program_vm_os_hardware.png" />
<p>Now, you write programs for the Java Virtual Machine, which is then ported
to each operating system, which is then ported to all the hardware. Whew!</p>
<p>This, of course, leads to the corollary to the previous maxim:</p>
<blockquote>
<p>...except for the problem of too many layers of indirection.</p>
<ul>
<li>Kevlin Henney</li>
</ul>
</blockquote>
<p>We now have a pattern:</p>
<ul>
<li>I have <code>A</code>.</li>
<li><code>A</code> is written explicitly for <code>X</code>...</li>
<li>... but I want to support <code>X</code> and <code>Y</code>,</li>
<li>so I put abstraction <code>B</code> in the middle.</li>
</ul>
<p>We will see this pattern over and over again. Hence ‘intermezzo’: abstractions
are always in the middle.</p>
<h2><a class="header" href="#isolation" id="isolation">Isolation</a></h2>
<p>Many of the abstractions provided are, as we discussed, abstractions over
hardware. And hardware often has a pretty serious restriction: only one
program can access the hardware at a time. So if our operating system is going
to be able to run multiple programs, which is a common feature of many
operating systems, we’ll also need to make sure that multiple programs cannot
access hardware at the same time.</p>
<p>This really applies to more than just hardware though: it also applies to
shared resources (e.g. memory). Once we have two programs, it would
be ideal to not let them mess with each other. Consider any sort of program that
deals with your password: if programs could mess with each other’s memory
and code, then a program could trivially steal your password from another program!</p>
<p>This is just one symptom of a general problem. It’s much better to isolate
programs from each other, for a number of different reasons. For now, we’ll
just consider isolation as one of our important jobs, as OS authors.</p>
<h3><a class="header" href="#wait-a-minute" id="wait-a-minute">Wait a minute...</a></h3>
<p>Here’s a question for you to ponder: if we didn’t provide isolation, isn’t that
just a poor abstraction? In other words, if we had an abstraction where we
could interact with other things being abstracted... isn’t that just a bad job
of doing the abstraction? And in that sense, is the only thing an operating
system does abstraction? Is the only thing everything does abstraction?</p>
<p>I don’t have answers for you. If you figure it out, let me know...</p>
<h1><a class="header" href="#what-kinds-of-os-are-there" id="what-kinds-of-os-are-there">What kinds of OS are there?</a></h1>
<p>Okay, so here’s the thing: operating systems are made up of a <em>lot</em> of components.
The core component is called a ‘kernel’. The non-kernel bits of an operating system
are collectively called a ‘userland’. Typically a kernel has more direct access to the
machine than a userland and thus acts somewhat like a super user (with powers that even
‘sudo’ cannot give you). A kernel forms the basis of the abstractions and isolations.
So, as OS developers, when we categorize operating systems, we tend to categorize them
by what kinds of kernel they have.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>Although you may be used to hearing the term ‘Linux’ used as a name for an
operating system, you may hear some people say, “It’s GNU/Linux, not Linux.”
That’s because virtually all Linux distributions today use a Linux kernel + a
GNU userland. So the GNU folks are a bit annoyed that the kernel gets all
the credit. By the same token, a lot of people say ‘the kernel’ when they mean
‘the Linux kernel.’ This gets an entirely different set of people mad.</p>
</blockquote>
<p>At the start, our ‘operating system’ will be just the kernel, and so we’ll tend
to focus on kernels for the first part of our journey.</p>
<p>The way that we categorize different kernels largely comes down to “what is in
the kernel and what is in userspace.” Upon reading this, you might then think
the easiest kind of kernel to write is the smallest, where everything is in
userspace. After all, smaller should be easier, right? Well... that’s not
actually true. Or at least, it’s not clear that it’s true.</p>
<h2><a class="header" href="#monolithic-kernels" id="monolithic-kernels">Monolithic kernels</a></h2>
<p>First, we have ‘monolithic kernels’. ‘Mono’ meaning ‘one’. One big ol’ kernel.
Most real-world kernels are monolithic kernels, or at least, pretend to be.
Don’t worry about it. Linux, for example, is a monolithic kernel.</p>
<p>This means that monolithic kernels are kind of ‘the default’. Other kernels
usually define themselves by solving some kind of problem that monolithic
kernels have.</p>
<p>If a monolithic kernel were a web application, it would be a big ol’ Rails
application. One repository. A million subdirectories. It may be a big ball
of mud, but it pays the bills.</p>
<h2><a class="header" href="#microkernels" id="microkernels">Microkernels</a></h2>
<p>Microkernels are, well, micro. Smaller. A lot of the functionality that’s typically in
the kernel is in userspace instead. This is a good idea in theory, but
historically, microkernels have had issues. All that communication has
overhead, which makes them slower.</p>
<p>Mach, the kernel that Mac OS X uses, is a microkernel. Well, sort of. It ended
up being one, but Mac OS X uses a version of Mach from before that work was
done... so it’s a bit blurry.</p>
<p>If a microkernel were a web application, it would be a microservice. And a
bunch of the other stuff that’s in kernel space in a monolithic kernel are
other microservices, but in userspace instead. It’s a bit cooler than a single
monolithic web app by itself, and the communication is nice for flexibility’s
sake, but has some overhead.</p>
<h2><a class="header" href="#exokernels--unikernels" id="exokernels--unikernels">Exokernels &amp; Unikernels</a></h2>
<p>These two kinds of operating systems are closely related, but it’s a bit harder
to dig into what exactly makes them different. Unikernels have one
easy-to-describe feature: they only run one single program at a time.
Exokernels are ‘more micro than micro’, but the details aren’t important right
now.</p>
<p>The important thing to know here is that there are a lot of other kinds of
designs than just monolithic vs. micro. There’s a lot of stuff to learn!</p>
<h1><a class="header" href="#what-kind-are-we-making" id="what-kind-are-we-making">What kind are we making?</a></h1>
<p>So, given all these kinds of operating systems, what kind are we making?</p>
<p>The answer is “it doesn’t even matter at first.” There’s some commonality in
almost all of these styles of operating systems, and we have to get all that
done before we even make those decisions.</p>
<p>Secondly, we could waste a <em>lot</em> of time trying to design our perfect OS. And
then never actually build it. Remember, the goal here is <em>to learn</em>, not <em>to
make the best OS that ever existed</em>. So really, what it ends up looking like
just doesn’t really matter at all. Most hobby operating system projects die
quite young.</p>
<p>Let’s focus on the <em>doing</em>, and less on the categorization, planning, and
being. A nice thing about operating systems is that there’s a lot of freedom of
direction. To tie it back into the example earlier, Phil’s tutorial starts
going into memory-management after getting printing to the screen going. We’ll
be going into keyboards first instead. There are, of course, some dependencies,
but there’s also a lot of freedom.</p>
<h1><a class="header" href="#what-tools-will-we-use" id="what-tools-will-we-use">What tools will we use?</a></h1>
<p>Before we can make a kernel, we need to figure out the tools we’re going to
use. The first question, of course, is what programming language?</p>
<p>In our case, we’re going to use two. The first one is the language that
<em>every</em> kernel must use: assembly language.</p>
<h2><a class="header" href="#assembly" id="assembly">Assembly</a></h2>
<p>Assembly language gives us direct access to a specific machine. If the basis of
computer science is abstraction, the very bottom of the software abstraction layer
is assembly. Below it lies only hardware and physics.</p>
<p>There are many kinds of assembly languages each targeted at different
‘instruction set’ architectures (also known as ISA or simply as instruction sets).
These instruction sets are the list of commands that a given CPU can understand. For
example, if your computer has an Intel Pentium processor of some kind then it
understands the x86 instruction set. So if you were to write assembly for another
instruction set (say MIPS or ARM), you would not be able to run it on your computer.</p>
<p>This is one of the reasons we'll want to get away from the assembly world as
fast as possible. If we want our kernel to work for a bunch of different
architectures, any code we end up writing in assembly will need to be duplicated.
However, if we use a more high-level language like C, C++ or the language we'll
really be using, Rust, we can write the code once and cross-compile
to different architectures.</p>
<p>Assembly language looks like this:</p>
<pre><code class="language-x86asm">; foo.asm

section .data
global _start

_start:
    mov rax, 0
loop:
    add rax, 1
    cmp rax, 10
    jne loop

    mov rbx, rax
    mov rax, 1
    int 80h
</code></pre>
<p>This is a little program in assembly language. If it looks totally alien to you,
don't worry. While we could write our entire kernel in assembly, we'll only be
learning as much assembly as we need to not have to use it any more.</p>
<p>When you write assembly language you are actually directly manipulating the
individual registers of the CPU and memory inside of RAM and other hardware
devices like CD drives or display screens.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>CPUs are composed of registers each of which can only hold small amounts of data.
The amount of data a register can hold dictates what type of CPU the register
belongs to. If you didn't know why your machine is classified as either 32 bit
or 64 bit it's because the machine's registers can either hold 32 bits of data at a
time or 64 bits at a time.</p>
</blockquote>
<p>In assembly we can only do very simple things: move data between registers or
to/from RAM; perform simple arithmetic like addition, subtraction, multiplication
and division; compare values in different registers, and based on these comparisons
jump to different points in our code (à la GOTO). Fancy high level concepts
like while loops and if statements, let alone garbage collection are nowhere to be
found. Even functions as you know them aren't really supported in assembly.
Each assembly program is just a bunch of data in registers or in memory and a
list of instructions, carried out one after the other.</p>
<p>For instance, in our code above we used the <code>mov</code> instruction several times to
move values into specific registers with weird names like <code>rax</code> and <code>rbx</code>. We
used the <code>cmp</code> instruction to compare the value inside of the <code>rax</code> register
with the number <code>10</code>. We used the <code>jne</code> instruction to jump to another part of
our code if the numbers we just compared were not equal. Finally we used the <code>int</code>
instruction to trigger a hardware <em>int</em>errupt.</p>
<p>Again, you don't need to fully understand this program at this point. Right now
you should just have an impression for how assembly is composed of simple
instructions that do very simple things.</p>
<p>When it comes time to write some actual assembly code we'll touch on all this again.</p>
<p>Let's run this little program:</p>
<pre><code class="language-bash">$ nasm -f elf64 foo.asm # assemble into foo.o
$ ld foo.o              # link into a.out
$ ./a.out               # run it
$ echo $?               # print out the exit code
10
$
</code></pre>
<p>Don't worry too much about what programs we're using to actually compile (or
‘assemble’ as it's known in the assembly world) our program. We'll be going
over each one of these commands and explaining what they are and how to use
them.</p>
<h2><a class="header" href="#rust" id="rust">Rust</a></h2>
<p>We will augment our assembly with code written in
<a href="https://www.rust-lang.org/">Rust</a>. In fact, we will be trying to get to
Rust-land as quickly as we possibly can. Rust is a really great programming
language, and it’s pretty great for writing operating systems. It has some
rough edges, but they’re not too big of a deal.</p>
<p>Rust will allow us to write:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">// foo.rs

use std::process;

fn main() {
    let mut a = 0;

    for _ in 0..10 {
        a = a + 1;
    }

    process::exit(a);
}
</code></pre></pre>
<p>This does the same thing as our assembly code:</p>
<pre><code class="language-bash">$ rustc foo.rs # compile our Rust code to foo
$ ./foo        # run it
$ echo $?      # print out the exit code
10
$
</code></pre>
<p>That Rust code probably looks more like a programming language you’ve used in
the past. It’s a lot nicer to write complex things in a higher-level
programming language like Rust. That said, virtually all languages are
higher-level than assembly, so that’s not saying all that much. Rust is still a
low-level language by many standards.</p>
<p>So why choose Rust? Well, I’m picking it for two reasons:</p>
<ol>
<li>I love it.</li>
<li>There aren’t a lot of kernels in it yet.</li>
</ol>
<p>There are a suprising number of people working on kernels in Rust. But since
it’s a newer language, there aren’t nearly as many as for older, more
established languages.</p>
<h2><a class="header" href="#do-i-need-to-be-a-wizard" id="do-i-need-to-be-a-wizard">Do I need to be a wizard?</a></h2>
<p>No, you do not. A common theme of this project is “this is all we’ll need to
know about this topic for now.” There’s no reason that you need to absolutely
master everything before going forward. For example, in order to get Rust
going, we need only about 100 lines of assembly, as mentioned above. Do you
need to be a complete expert in assembly language to understand those well
enough to keep going? Not at all. Will learning more about it help? Absolutely!</p>
<p>There’s nobody that’s monitoring your credentials to see if you’re allowed to
move on. Do it at your own pace. Skip stuff. Come back when you don’t
understand what’s going on. Try it, wait a week, and then try it again.</p>
<p>There’s no wrong way to do this stuff, including by being a beginner. Everyone
was once. Don’t let anyone discourage you.</p>
<h1><a class="header" href="#setting-up-a-development-environment" id="setting-up-a-development-environment">Setting up a development environment</a></h1>
<p>Frankly, one of the hardest parts of starting an operating system is getting a
development environment going. Normally, you’re doing work on the same
operating system you’re developing for, and we don’t have that luxury. Yet!</p>
<p>There is a convention called a ‘target triple’ to describe a particular
platform. It’s a ‘triple’ because it has three parts:</p>
<pre><code class="language-text">arch-kernel-userland
</code></pre>
<p>So, a target triple for a computer which has an x86-64 bit processor running a
Linux kernel and the GNU userland would look like this:</p>
<pre><code class="language-text">x86_64-linux-gnu
</code></pre>
<p>However, it can also be useful to know the operating system as well, and so
the ‘triple’ part can be extended to include it:</p>
<pre><code class="language-text">x86_64-unknown-linux-gnu
</code></pre>
<p>This is for some unknown Linux. If we were targeting Debian specifically, it
would be:</p>
<pre><code class="language-text">x86_64-debian-linux-gnu
</code></pre>
<p>Since it’s four parts, it’s called a ‘target’ rather than a ‘target triple’,
but you’ll still hear some people call it a triple anyway.</p>
<p>Kernels themselves don’t need to be for a specific userland, and so you’ll
see ‘none’ get used:</p>
<pre><code class="language-text">x86_64-unknown-none
</code></pre>
<h2><a class="header" href="#hosts--targets" id="hosts--targets">Hosts &amp; Targets</a></h2>
<p>The reason that they’re called a ‘target’ is that it’s the architecture you’re
compiling <em>to</em>. The architecture you’re compiling <em>from</em> is called the ‘host
architecture’.</p>
<p>If the target and the host are the same, we call it ‘compiling’. If they are
different, we call it ‘cross-compiling’. So you’ll see people say things like</p>
<blockquote>
<p>I cross-compiled from x86_64-linux-gnu to x86-unknown-none.</p>
</blockquote>
<p>This means that the computer that the developer was using was a 64-bit
GNU/Linux machine, but the final binary was for a 32-bit x86 machine with no
OS.</p>
<p>So we need a slightly special environment to build our OS: we need to
cross-compile from whatever kind of computer we are using to our new target.</p>
<h2><a class="header" href="#cheat-codes" id="cheat-codes">Cheat codes</a></h2>
<p>... but we can also cheat. It’s okay to cheat. Well, in this case, it’s really
only okay at the start. We’ll eventually <em>have</em> to cross-compile, or things
will go wrong.</p>
<p>Here’s the cheat: if you are developing on an x86_64 Linux machine, and you’re
not using any special Linux kernel features, then the difference between
<code>x86_64-linux-gnu</code> and <code>x86_64-unknown-none</code> is really just theoretical. It
will still technically <em>work</em>. For now.</p>
<p>This is a common pitfall with new operating system developers. They’ll start
off with the cheat, and it will come back to haunt them later. Don’t worry;
I will actually show you how to fix things before they go wrong. Knowing the
difference here is still useful.</p>
<h1><a class="header" href="#installing-rust" id="installing-rust">Installing Rust</a></h1>
<p>First, you need to get a copy of Rust! There's one catch though: you'll need to
get <em>exactly</em> the correct version of Rust. Unfortunately, for OS development,
we need to take advantage of some cutting-edge features that aren't yet stable.</p>
<p>Luckily, the Rust project has a tool that makes it easy to switch between Rust
versions: <code>rustup</code>. You can get it from the <a href="http://rust-lang.org/install.html">install
page</a> of the Rust website.</p>
<p>By default, <code>rustup</code> uses stable Rust. So let's tell it to install nightly:</p>
<pre><code class="language-bash">$ rustup update nightly
</code></pre>
<p>This installs the current version of nightly Rust. We run all of the examples
in this book under continuous integration, so we should know if something
changes in nightly Rust and breaks. But please <a href="https://github.com/intermezzOS/book/issues/new">file bugs</a> if something doesn't
work.</p>
<p>Because nightly Rust includes unstable features, you shouldn't use it unless
you really need to, which is why <code>rustup</code> allows you to override the default
version only when you're in a particular directory. We don't have a directory
for our project yet, so let's create one:</p>
<pre><code class="language-bash">$ mkdir intermezzOS
$ cd intermezzOS
</code></pre>
<p>A fun way to follow along is to pick a different name for your kernel, and
then change it as we go. Call your kernel whatever you want. intermezzOS was
almost called ‘Nucleus’, until I found out that there’s already a kernel with
that name that’s installed on billions of embedded devices. Whoops!</p>
<p>Inside your project directory, set up the override:</p>
<pre><code class="language-bash">$ rustup override add nightly
</code></pre>
<p>Nice and easy. We can't get the version wrong; <code>rustup</code> handles it for us.</p>
<h1><a class="header" href="#linux" id="linux">Linux</a></h1>
<p>Here are the tools we’re going to need:</p>
<ul>
<li><code>nasm</code></li>
<li><code>ld</code></li>
<li><code>grub-mkrescue</code> + <code>xorriso</code></li>
<li><code>qemu</code></li>
</ul>
<p>How to install the tools depends on your distribution.</p>
<p>On Debian you can install them with</p>
<pre><code class="language-bash">$ sudo apt-get install nasm xorriso qemu build-essential
</code></pre>
<p>On Arch Linux you can install them with</p>
<pre><code class="language-bash">$ sudo pacman -S --needed binutils grub mtools libisoburn nasm qemu
</code></pre>
<p>And on Fedora with</p>
<pre><code class="language-bash">$ sudo dnf install nasm xorriso qemu
</code></pre>
<p>Note that if your Fedora is up-to-date enough you will need to call <code>grub2-mkrescue</code> command instead of <code>grub-mkrescue</code>.</p>
<h1><a class="header" href="#mac-os-x" id="mac-os-x">Mac OS X</a></h1>
<p>The tools you need are similar to the tools listed in the <a href="linux.html">Linux
instructions</a>, but we will need to build a cross compiler in
order to get things working. This is sort of complicated and boring, but we've
done some of that boring work for you so you can get up and running quickly.</p>
<p>Make sure you have <a href="http://brew.sh/">homebrew</a> installed because you are going
to need it to install some of the tools. You are probably also going to need
<a href="https://developer.apple.com/xcode/download/">Xcode</a> if you don't already have
it. You <em>may</em> have to agree to the Xcode license before you use it. You can do
this by either opening Xcode and accepting the license agreement, or by running
<code>sudo xcodebuild -license</code> in the terminal, scrolling down to the bottom of the
license, and agreeing to it.</p>
<p>Download <a href="appendix/osx-install.html">this script</a> and <em>read</em> through it. There are a couple assumptions
that it makes about the paths where the source is downloaded to and where the
binaries are installed.  You might want to change where those locations are.
When possible we try and use <code>brew</code> to install things, but there are some
programs we need to compile.  The compiled special versions of the tools are
installed in <code>~/opt</code>. This is so we don't clobber any version of them that you
may have already installed. The source code for these tools are downloaded in
<code>~/src</code>.</p>
<p>Here is what the script does:</p>
<ol>
<li><code>brew install</code> tools that it can like <code>gmp</code>, <code>mpfr</code>, <code>libmpc</code>, <code>autoconf</code>, and <code>automake</code></li>
<li>Download and compile tools in order to make a cross compiler: <code>binutils</code>, <code>gcc</code>, <code>objconv</code></li>
<li>Download and compile <code>grub</code> using the cross compiler</li>
</ol>
<p>This might take some time to run.</p>
<p>After it is done you should have all the tools you need located in <code>~/opt</code>. The
tools <em>should</em> be named the same as the tools used in other chapters, but they
might be prefixed with a <code>x86_64-pc-elf-</code>. The exception to this is <code>grub</code>. The
default path for the binaries installed using the above script is <code>$HOME/opt/bin</code> so adjust the PATH variable appropriately.</p>
<h1><a class="header" href="#windows" id="windows">Windows</a></h1>
<h1><a class="header" href="#windows-10" id="windows-10">Windows 10</a></h1>
<p>If you're using Windows 10, you can use <a href="https://msdn.microsoft.com/en-us/commandline/wsl/about">Bash On Ubuntu on
Windows</a> to get
going in an easy way.</p>
<p>Once you have installed Bash on Ubuntu on Windows, simply follow the <a href="linux.html">Linux
instructions</a>. You'll also need the <code>grub-pc-bin</code> package.</p>
<p>Finally, you'll need an &quot;X server&quot;; this will let us run intermezzOS in a
graphical window. Any will do, but we've tried
<a href="https://sourceforge.net/projects/xming/">xming</a> and it works well.</p>
<p>Finally, you'll need to run this:</p>
<pre><code class="language-bash">$ export DISPLAY=:0
</code></pre>
<p>You can put it in your <code>~/.bashrc</code> file to have it automatically work on each
session.</p>
<h2><a class="header" href="#other-windows-versions" id="other-windows-versions">Other Windows Versions</a></h2>
<p>I hope to have better instructions for Windows soon; since I don’t have a
computer that runs it, I need to figure it out first. If you know how, this
would be a great way to <a href="https://github.com/intermezzOS/book">contribute</a>.</p>
<h1><a class="header" href="#booting-up" id="booting-up">Booting up</a></h1>
<p>We’ve got some of the theory down, and we’ve got a development environment
going. Let’s get down to actually writing some code, shall we?</p>
<p>Our first task is going to be the same as in any programming language: Hello
world! It’s going to take a <em>teeny</em> bit more code than in many languages. For
example, here’s “Hello, World!” in Ruby:</p>
<pre><code class="language-ruby">puts &quot;Hello, world!&quot;
</code></pre>
<p>Or in C:</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;

int main(void) {
    printf(&quot;Hello, world!&quot;);
}
</code></pre>
<p>But it’s not actually <em>that</em> much more work. It’s going to take us <em>28 lines</em>
to get there. And instead of a single command to build and run, like Ruby:</p>
<pre><code class="language-bash">$ ruby hello_world.rb
</code></pre>
<p>It’s going to initially take us six commands to build and run our hello world
kernel. Don’t worry, the next thing we’ll do is write a script to turn it back
into a single command.</p>
<p>By the way, <a href="appendix/troubleshooting.html">Appendix A</a> has a list of solutions
to common problems, if you end up getting stuck.</p>
<h1><a class="header" href="#multiboot-headers" id="multiboot-headers">Multiboot headers</a></h1>
<p>Let’s get going! The very first thing we’re going to do is create a ‘multiboot
header’. What’s that, you ask? Well, to explain it, let’s take a small step
back and talk about how a computer boots up.</p>
<p>One of the amazing and terrible things about the x86 architecture is that it’s
maintained backwards compatibility throughout the years. This has been a
competitive advantage, but it’s also meant that the boot process is largely a
pile of hacks. Each time a new iteration comes out, a new step gets added to
the process. That’s right, when your fancy new computer starts up, it thinks
it’s an 8086 from 1976. And then, through a succession of steps, we transition
through more and more modern architectures until we end at the latest and
greatest.</p>
<p>The first mode is called ‘real mode’. This is a 16 bit mode that the original
x86 chips used. The second is ‘protected mode’. This 32 bit mode adds new
things on top of real mode. It’s called ‘protected’ because real mode sort of
let you do whatever you wanted, even if it was a bad idea. Protected mode was
the first time that the hardware enabled certain kinds of protections that allow
us to exercise more control around such things as RAM. We’ll talk more about
those details later.</p>
<p>The final mode is called ‘long mode’, and it’s 64 bits.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>Well, that’s actually a lie: there’s two. Initially, you’re not in long mode,
you’re in ‘compatibility mode’. You see, when the industry was undergoing the
transition from 32 to 64 bits, there were two options: the first was Intel’s
Itanium 64-bit architecture. It did away with all of the stuff I just told
you about. But that meant that programs had to be completely recompiled from
scratch for the new chips. Intel’s big competitor, AMD, saw an opportunity
here, and released a new set of chips called amd64. These chips were backwards
compatible, and so you could run both 32 and 64 bit programs on them.
Itanium wasn’t compelling enough to make the pain worth it, and so Intel released
new chips that were compatible with amd64. The resulting architecture was then
called x86_64, the one we’re using today. The moral of the story? Intel tried
to save you from all of the stuff we’re about to do, but they failed. So
we have to do it.</p>
</blockquote>
<p>So that’s the task ahead of us: make the jump up the ladder and get to
long mode. We can do it! Let’s talk more details.</p>
<h2><a class="header" href="#firmware-and-the-bios" id="firmware-and-the-bios">Firmware and the BIOS</a></h2>
<p>So let's begin by turning the power to our computer on.</p>
<p>When we press the power button, electricity starts running, and a special piece of
software, known as the BIOS in Intel land, automatically runs.</p>
<p>With the BIOS we're already in the land of software, but unlike software that
you may be used to writing, the BIOS comes bundled with its computer and is located in
<em>r</em>ead-<em>o</em>nly <em>m</em>emory (ROM). While changing or updating stuff in ROM
is possible, it's not something you can do by invoking your favorite
package manager or by downloading something from some website. In fact some ROM
is literally hardwired into the computer and cannot be changed without
physically swapping it out. This makes sense here. The BIOS and the
computer are lifetime partners. Their existence doesn't make much sense without
each other.</p>
<p>One of the first things the BIOS does is run a ‘POST’ or <em>p</em>ower-<em>o</em>n <em>s</em>elf-<em>t</em>est
which checks for the availability and integrity of all the pieces of hardware that
the computer needs including the BIOS itself, CPU registers, RAM, etc. If you've
ever heard a computer beeping at you as it boots up, that's the POST reporting
its findings.</p>
<p>Assuming no problems are found, the BIOS starts the real booting process.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>For a while now most commercial computer manufacturers have hidden their BIOS
booting process behind some sort of splash screen. It's usually possible to see the
BIOS' logs by pressing some collection of keys when your computer is starting up.</p>
<p>The BIOS also has a menu where you can see information about the computer
like CPU and memory specs and all the hardware the BIOS detected like hard drives
and CD and DVD drives. Typically this menu is accessed by pressing some other
weird collection of keyboard keys while the computer is attempting to boot.</p>
</blockquote>
<p>The BIOS automatically finds a ‘bootable drive’ by looking in certain
pre-determined places like the computer's hard drive and CD and DVD drives.
A drive is ‘bootable’ if it contains software that can finish the booting
process. In the BIOS menu you can usually change in what order the BIOS looks
for bootable drives or tell it to boot from a specific drive.</p>
<p>The BIOS knows it's found a bootable drive by looking at the first few kilobytes
of the drive and looking for some magical numbers set in that drive's
memory. This won't be the last time some magical numbers or hacky sounding things
are used on our way to building an OS. Such is life at such a low level...</p>
<p>When the BIOS has found its bootable drive, it loads part of the drive into
memory and transfers execution to it. With this process, we move away from what
comes dictated by the computer manufacturer and move ever closer to getting our
OS running.</p>
<h2><a class="header" href="#bootloaders" id="bootloaders">Bootloaders</a></h2>
<p>The part of our bootable drive that gets executed is called a ‘bootloader’,
since it loads things at boot time. The bootloader’s job is to take our kernel,
put it into memory, and then transition control to it.</p>
<p>Some people start their operating systems journey by writing a bootloader. We
will not be doing that. Frankly, this whole startup process is more of an
exercise in reading manuals and understanding the history of esoteric hardware
than it is anything else. That stuff may interest you, and maybe someday we’ll
come back and write a bootloader of our own.</p>
<p>In the interest of actually getting around to implementing a kernel, instead, we’ll
use an existing bootloader: GRUB.</p>
<h2><a class="header" href="#grub-and-multiboot" id="grub-and-multiboot">GRUB and Multiboot</a></h2>
<p>GRUB stands for ‘<em>gr</em>and <em>u</em>nified <em>b</em>ootloader’, and it’s a common one for
GNU/Linux systems. GRUB implements a specification called Multiboot, which is a
set of conventions for how a kernel should get loaded into memory. By following
the Multiboot specification, we can let GRUB load our kernel.</p>
<p>The way that we do this is through a ‘header’. We’ll put some information in a
format that multiboot specifies right at the start of our kernel. GRUB will
read this information, and follow it to do the right thing.</p>
<p>One other advantage of using GRUB: it will handle the transition from real mode
to protected mode for us, skipping the first step. We don’t even need to know
anything about all of that old stuff. If you’re curious about the kinds of
things you would have needed to know, put “A20 line” into your favorite search
engine, and get ready to cry yourself to sleep.</p>
<h2><a class="header" href="#writing-our-own-multiboot-header" id="writing-our-own-multiboot-header">Writing our own Multiboot header</a></h2>
<p>I said we were gonna get to the code, and then I went on about more history.
Sorry about that! It’s code time for real! Inside your project directory, make
a new file called <code>multiboot_header.asm</code>, and open it in your favorite editor.
I use <code>vim</code>, but you should feel free to use anything you’d like.</p>
<pre><code class="language-bash">$ touch multiboot_header.asm
$ vim multiboot_header.asm
</code></pre>
<p>Two notes about this: first of all, we’re just making this source file in the
top level. Don’t worry, we’ll clean house later. Remember: we’re going to build
stuff, and <em>then</em> abstract it afterwards. It’s easier to start with a mess and
clean it up than it is to try to get it perfect on the first try.</p>
<p>Second, this is a <code>.asm</code> file, which is short for ‘assembly’. That’s right, we’re
going to write some assembly code here. Don’t worry! It’s not super hard.</p>
<h3><a class="header" href="#an-aside-about-assembly" id="an-aside-about-assembly">An aside about assembly</a></h3>
<p>Have you ever watched Rich Hickey’s talk “Simple vs. Easy”? It’s a wonderful talk.
In it, he draws a distinction between these two words, which are commonly used as
synonyms.</p>
<p>TODO https://github.com/intermezzOS/book/issues/27</p>
<p>Assembly coding is simple, but that doesn’t mean that it’s easy. We’ll be doing
a little bit of assembly programming to build our operating system, but we
don’t need to know <em>that much</em>. It is completely learnable, even for someone
coming from a high-level language. You might need to practice a bit, and take
it slow, but I believe in you. You’ve got this.</p>
<h3><a class="header" href="#the-magic-number" id="the-magic-number">The Magic Number</a></h3>
<p>Our first assembly file will be almost entirely <em>data</em>, not code. Here’s the
first line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
</code></pre>
<p>Ugh! Gibberish! Let’s start with the semicolon (<code>;</code>). It’s a comment, that
lasts until the end of the line. This particular comment says ‘magic number’.
As we said, you’ll be seeing a lot of magic numbers in your operating system work.
The idea of a magic number is that it’s completely and utterly arbitrary. It
doesn’t mean anything. It’s just magic. The very first thing that the multiboot
specification requires is that we have the magic number <code>0xe85250d6</code> right
at the start.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>Wondering how a number can have letters inside of it? <code>0xe85250d6</code> is written in
hexadecimal notation. Hexadecimal is an example of a &quot;numeral system&quot; which is a
fancy term for a system for conveying numbers. The numeral system you're probably most
familiar with is the decimal system which conveys numbers using a combination of the
symbols <code>0</code> - <code>9</code>. Hexadecimal on the other hand uses a combination of 16 symbols:
<code>0</code> - <code>9</code> and <code>a</code> - <code>f</code>. Along with its fellow numeral system, binary, hexadecimal
is used <em>a lot</em> in low level programming. In order to tell if a number is written
in hexadecimal, you may be tempted to look for the use of letters in the number,
but a more surefire way is to look for a leading <code>0x</code>. While <code>100</code> isn't a hexadecimal
number, <code>0x100</code> is. To learn more about hexadecimal and binary <a href="appendix/numeral-systems.html">check this
out</a>.</p>
</blockquote>
<p>What’s the value in having an arbitrary number there? Well, it’s a kind of safeguard
against bad things happening. This is one of the ways in which we can check that
we actually have a real multiboot header. If it doesn’t have the magic number,
something has gone wrong, and we can throw an error.</p>
<p>I have no idea why it’s <code>0xe85250d6</code>, and I don’t need to care. It just is.</p>
<p>Finally, the <code>dd</code>. It’s short for ‘define double word’. It declares that we’re
going to stick some 32-bit data at this location. Remember, when x86 first started,
it was a 16-bit architecture set. That meant that the amount of data that could be
held in a CPU register (or one ‘word’ as it's commonly known) was 16 bits.
To transition to a 32-bit architecture without losing backwards compatibility,
x86 got the concept of a ‘double word’ or double 16 bits.</p>
<h3><a class="header" href="#the-mode-code" id="the-mode-code">The mode code</a></h3>
<p>Okay, time to add a second line:</p>
<pre><code class="language-x86asm">dd 0xe85250d6 ; magic number
dd 0          ; protected mode code
</code></pre>
<p>This is another form of magic number. We want to boot into protected mode, and
so we put a zero here, using <code>dd</code> again. If we wanted GRUB to do something
else, we could look up another code, but this is the one that we want.</p>
<h3><a class="header" href="#header-length" id="header-length">Header length</a></h3>
<p>The next thing that’s required is a header length. We could use <code>dd</code> and count
out exactly how many bytes that our header is, but there’s two reasons why
we’re not doing that:</p>
<ol>
<li>Computers should do math, not people.</li>
<li>We’re going to add more stuff, and we’d have to recalculate this number each
time. Or wait until the end and come back. See #1.</li>
</ol>
<p>Here’s what this looks like:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length
header_end:
</code></pre>
<p>You don’t have to align the comments if you don’t want to. I usually don’t, but
it looks nice and after we’re done with this file, we’re not going to mess with
it again, so we won’t be constantly re-aligning them in the future.</p>
<p>The <code>header_start:</code> and <code>header_end:</code> things are called ‘labels’. Labels let
us use a name to refer to a particular part of our code. Labels also refer to the
memory occupied by the data and code which directly follows it. So in our code above
the label <code>header_start</code> points directly to the memory at the very beginning of our
magic number and thus to the very beginning of our header.</p>
<p>Our third <code>dd</code> line uses those two labels to do some math: the header length is
the value of <code>header_end</code> minus the value of <code>header_start</code>. Because <code>header_start</code>
and <code>header_end</code> are just the addresses of places in memory, we can simply subtract
to get the distance between those two addresses. When we compile this assembly
code, the assembler will do this calculation for us. No need to figure out
how many bytes there are by hand. Awesome.</p>
<p>You’ll also notice that I indented the <code>dd</code> statements. Usually, labels go in
the first column, and you indent actual instructions. How much you indent is up
to you; it’s a pretty flexible format.</p>
<h3><a class="header" href="#the-checksum" id="the-checksum">The Checksum</a></h3>
<p>The fourth field multiboot requires is a ‘checksum’. The idea is that we sum up
some numbers, and then use that number to check that they’re all what we
expected things to be. It’s similar to a hash, in this sense: it lets us and GRUB
double-check that everything is accurate.</p>
<p>Here’s the checksum:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))
header_end:
</code></pre>
<p>Again, we’ll use math to let the computer calculate the sum for us. We add up
the magic number, the mode code, and the header length, and then subtract it
from a big number. <code>dd</code> then puts that value into this spot in our file.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>You might wonder why we're subtracting these values from 0x100000000. To answer this we can look at what <a href="http://nongnu.askapache.com/grub/phcoder/multiboot.pdf">the multiboot spec</a> says about the checksum value in the header:</p>
<blockquote>
<p>The field <code>checksum</code> is a 32-bit <a href="http://intermezzos.github.io/book/appendix/signed-and-unsigned.html">unsigned value</a> which, when added to the other magic fields (i.e. <code>magic</code>, <code>architecture</code> and <code>header_length</code>), must have a 32-bit unsigned sum of zero.</p>
</blockquote>
<p>In other words:</p>
<p><code>checksum</code> + <code>magic_number</code> + <code>architecture</code> + <code>header_length</code> = 0</p>
<p>We could try and &quot;solve for&quot; <code>checksum</code> like so:</p>
<p><code>checksum</code> =  -(<code>magic_number</code> + <code>architecture</code> + <code>header_length</code>)</p>
<p>But here's where it gets weird. Computers don't have an innate concept of negative numbers. Normally we get around this by using &quot;signed integers&quot;, which is something we <a href="http://intermezzos.github.io/book/appendix/signed-and-unsigned.html">cover in an appendix</a>. The point is we have an unsigned integer here, which means we're limited to representing only positive numbers. This means we can't literally represent -(<code>magic_number</code> + <code>architecture</code> + <code>header_length</code>) in our field.</p>
<p>If you look closely at the spec you'll notice it's strangely worded: it's asking for a value that when added to other values has a sum of zero. It's worded this way because integers have a limit to the size of numbers they can represent, and when you go over that size, the values wrap back around to zero. So 0xFFFFFFFF + 1 is.... 0x00000000. This is a hardware limitation: technically it's doing the addition correctly, giving us the 33-bit value 0x100000000, but we only have 32 bits to store things in so it can't actually tell us about that <code>1</code> in the most significant digit position! We're left with the rest of the digits, which spell out zero.</p>
<p>So what we can do here is &quot;trick&quot; the computer into giving us zero when we do the addition. Imagine for the sake of argument that <code>magic_number</code> + <code>architecture</code> + <code>header_length</code> somehow works out to be 0xFFFFFFFE. The number we'd add to that in order to make 0 would be 0x00000002. This is 0x100000000-0xFFFFFFFE, because 0x100000000 technically maps to 0 when we wrap around. So we replace 0xFFFFFFFE in our contrived example here with <code>magic_number</code> + <code>architecture</code> + <code>header_length</code>. This gives us:
<code>dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))</code></p>
</blockquote>
<h3><a class="header" href="#ending-tag" id="ending-tag">Ending tag</a></h3>
<p>After the checksum you can list a series of “tags”, which is a way for the OS to
tell the bootloader to do some extra things before handing control over to the
OS, or to give the OS some extra information once started. We donʼt need any of
that yet, though, so we just need to include the required “end tag”, which looks
like this:</p>
<pre><code class="language-x86asm">header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>
<p>Here we use <code>dw</code> to define a ‘word’ instead of just data. Remember a ‘word’ is 16
bits or 2 bytes on the x86_64 architecture. The multiboot specification demands
that this be exactly a word. You’ll find that this is super common in operating systems:
the exact size and amount of everything matters. It’s just a side-effect of
working at a low level.</p>
<h3><a class="header" href="#the-section" id="the-section">The Section</a></h3>
<p>We have one last thing to do: add a ‘section’ annotation. We’ll talk more about
sections later, so for now, just put what I tell you at the top of the file.</p>
<p>Here’s the final file:</p>
<pre><code class="language-x86asm">section .multiboot_header
header_start:
    dd 0xe85250d6                ; magic number
    dd 0                         ; protected mode code
    dd header_end - header_start ; header length

    ; checksum
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; required end tag
    dw 0    ; type
    dw 0    ; flags
    dd 8    ; size
header_end:
</code></pre>
<p>That’s it! Congrats, you’ve written a multiboot compliant header. It’s a lot of
esoterica, but it’s pretty straightforward once you’ve seen it a few times.</p>
<h2><a class="header" href="#assembling-with-nasm" id="assembling-with-nasm">Assembling with <code>nasm</code></a></h2>
<p>We can’t use this file directly, we need to turn it into binary. We can use a
program called an ‘assembler’ to ‘assemble’ our assembly code into binary code.
It’s very similar to using a ‘compiler’ to ‘compile’ our source code into
binary. But when it’s assembly, people often use the more specific name.</p>
<p>We will be using an assembler called <code>nasm</code> to do this. You should invoke
<code>nasm</code> like this:</p>
<pre><code class="language-bash">$ nasm -f elf64 multiboot_header.asm
</code></pre>
<p>The <code>-f elf64</code> says that we want to output a file using the <code>elf64</code> file
<em>f</em>ormat. ELF is a particular executable format that’s used by various UNIX
systems, and we’ll be using it too. The executable format just specifies how
exactly the bits will be laid out in the file. For example, will there be a
magic number at the beginning of the file for easier error checking? Or where in
the file do we specify whether our code and data is in a 32-bit or 64-bit
format? There are other formats, but ELF is pretty good.</p>
<p>After you run this command, you should see a <code>multiboot_header.o</code> file in
the same directory. This is our ‘object file’, hence the <code>.o</code>. Don't let the
word ‘object’ confuse you. It has nothing to do with anything object oriented.
‘Object files’ are just binary code with some metadata in a particular format -
in our case ELF. Later, we’ll take this file and use it to build our OS.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>Congratulations! This is the first step towards building an operating system.
We learned about the boot process, the GRUB bootloader, and the Multiboot
specification. We wrote a Multiboot-compliant header file in assembly code, and
used <code>nasm</code> to create an object file from it.</p>
<p>Next, we’ll write the actual code that prints “Hello world” to the screen.</p>
<h1><a class="header" href="#hello-world" id="hello-world">Hello, world!</a></h1>
<p>Now that we’ve got the headers out of the way, let’s do the traditional first
program: Hello, world!</p>
<h2><a class="header" href="#the-smallest-kernel" id="the-smallest-kernel">The smallest kernel</a></h2>
<p>Our hello world will be just <em>20</em> lines of assembly code. Let’s begin.
Open a file called <code>boot.asm</code> and put this in it:</p>
<pre><code class="language-x86asm">start:
    hlt
</code></pre>
<p>You’ve seen the <code>name:</code> form before: it’s a <em>label</em>. This lets us name a line
of code. We’ll call this label <code>start</code>, which is the traditional name.
GRUB will use this convention to know where to begin.</p>
<p>The <code>hlt</code> statement is our first bit of ‘real’ assembly. So far, we had just
been declaring data. This is actual, executable code. It’s short for ‘halt’.
In other words, it ends the program.</p>
<p>By giving this line a label, we can call it, sort of like a function. That’s what
GRUB does: “Call the function named <code>start</code>.” This function has just one
line: stop.</p>
<p>Unlike many other languages, you’ll notice that there’s no way to say if
this ‘function’ takes any arguments or not. We’ll talk more about that later.</p>
<p>This code won’t quite work on its own though. We need to do a little bit more
bookkeeping first. Here’s the next few lines:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    hlt
</code></pre>
<p>Three new bits of information. The first:</p>
<pre><code class="language-x86asm">global start
</code></pre>
<p>This says “I’m going to define a label <code>start</code>, and I want it to be available
outside of this file.” If we don’t say this, GRUB won’t know where to find its
definition. You can kind of think of it like a ‘public’ annotation in other
languages.</p>
<pre><code class="language-x86asm">section .text
</code></pre>
<p>We saw <code>section</code> briefly, but I told you we’d get to it later. The place where
we get to it is at the end of this chapter. For the moment, all you need to
know is this: code goes into a section named <code>.text</code>. Everything that comes
after the <code>section</code> line is in that section, until another <code>section</code> line.</p>
<pre><code class="language-x86asm">bits 32
</code></pre>
<p>GRUB will boot us into protected mode, aka 32-bit mode. So we have to specify
that directly. Our Hello World will only be in 32 bits. We’ll transition from
32-bit mode to 64-bit mode in the next chapter, but it’s a bit involved.
So let’s just stay in protected mode for now.</p>
<p>That’s it! We could theoretically stop here, but instead, let’s actually print
the “Hello world” text to the screen. We’ll start off with an ‘H’:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    hlt
</code></pre>
<p>This new line is the most complicated bit of assembly we’ve seen yet. There’s a
lot packed into this little line.</p>
<p>The first important bit is <code>mov</code>. This is short for <code>move</code>, and it sorta looks
like this:</p>
<pre><code class="language-text">mov size place, thing
</code></pre>
<p>Oh, <code>;</code> starts a comment, remember? So the <code>; H</code> is just for us. I put this
comment here because this line prints an <code>H</code> to the screen!</p>
<p>Yup, it does. Okay, so here’s why: <code>mov</code> copies <code>thing</code> into <code>place</code>. The amount
of stuff it copies is determined by <code>size</code>.</p>
<pre><code class="language-x86asm">;   size place      thing
;   |    |          |
;   V    V          V
mov word [0xb8000], 0x0248 ; H
</code></pre>
<p>“Copy one word: the number <code>0x0248</code> to ... some place.</p>
<p>The <code>place</code> looks like a number just like <code>0x0248</code>, but it has square 
brackets <code>[]</code> around it. Those brackets are special. They mean “the address 
in memory located by this number.” In other words, we’re copying the number 
<code>0x0248</code> into the specific memory location <code>0xb8000</code>. That’s what this line does.</p>
<p>Why? Well, we’re using the screen as a “memory mapped” device. Specific
positions in memory correspond to certain positions on the screen. And
the position <code>0xb8000</code> is one of those positions: the upper-left corner of the
screen.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>&quot;Memory mapping&quot; is one of the fundamental techniques used in computer
engineering to help the CPU know how to talk to all the different physical
components of a computer. The CPU itself is just a weird little machine that
moves numbers around. It's not of any use to humans on its own: it needs to be
connected to devices like RAM, hard drives, a monitor, and a keyboard. The way
the CPU does this is through a <em>bus</em>, which is a huge pipeline of wires
connecting the CPU to every single device that might have data the CPU needs.
There's one wire per bit (since a wire can store a 1 or a 0 at any given time).
A 32-bit bus is literally 32 wires in parallel that run from the CPU to a bunch
of devices like Christmas lights around a house.</p>
<p>There are two buses that we really care about in a computer: the address bus
and the data bus. There's also a third signal that lets all the devices know
whether the CPU is requesting data from an input (reading, like from the
keyboard) or sending data to an output (writing, like to the monitor via the
video card). The address bus is for the CPU to send location information, and
the data bus is for the CPU to either write data to or read data from that
location.  Every device on the computer has a unique hard coded numerical
location, or &quot;address&quot;, literally determined by how the thing is wired up at
the factory. In the case of an input/read operation, when it sends <code>0x1001A003</code>
out on the address bus and the control signal notifies every device that it's a
read operation, it's asking, &quot;What is the data currently stored at location
<code>0x1001A003</code>?&quot; If the keyboard happens to be identified by that particular
address, and the user is pressing SPACE at this time, the keyboard says, &quot;Oh,
you're talking to me!&quot; and sends back the ASCII code <code>0x00000020</code> (for &quot;SPACE&quot;)
on the data bus.</p>
<p>What this means is that memory on a computer isn't just representing things like
RAM and your hard drive. Actual human-scale devices like the keyboard and mouse
and video card have their own memory locations too. But instead of writing a byte
to a hard drive for storage, the CPU might write a byte representing some color
and symbol to the monitor for display. There's an industry standard somewhere
that says video memory must live in the address range beginning <code>0xb8000</code>. In
order for computers to be able to work out of the box, this means that the BIOS
needs to be manufactured to assume video lives at that location, and the
motherboard (which is where the bus is all wired up) has to be manufactured to
route a <code>0xb8000</code> request to the video card.  It's kind of amazing this stuff
works at all! Anyway, &quot;memory mapped hardware&quot;, or &quot;memory mapping&quot; for short,
is the name of this technique.</p>
</blockquote>
<p>Now, we are copying <code>0x0248</code>. Why this number? Well, it’s in three parts:</p>
<pre><code class="language-text"> __ background color
/  __foreground color
| /
V V
0 2 48 &lt;- letter, in ASCII
</code></pre>
<p>We’ll start at the right. First, two numbers are the letter, in ASCII. <code>H</code> is
72 in ASCII, and 48 is 72 in hexadecimal: <code>(4 * 16) + 8 = 72</code>. So this will
write <code>H</code>.</p>
<p>The other two numbers are colors. There are 16 colors available, each with a
number. Here’s the table:</p>
<pre><code class="language-text">| Value | Color          |
|-------|----------------|
| 0x0   | black          |
| 0x1   | blue           |
| 0x2   | green          |
| 0x3   | cyan           |
| 0x4   | red            |
| 0x5   | magenta        |
| 0x6   | brown          |
| 0x7   | gray           |
| 0x8   | dark gray      |
| 0x9   | bright blue    |
| 0xA   | bright green   |
| 0xB   | bright cyan    |
| 0xC   | bright red     |
| 0xD   | bright magenta |
| 0xE   | yellow         |
| 0xF   | white          |
</code></pre>
<p>So, <code>02</code> is a black background with a green foreground. Classic. Feel free to
change this up, use whatever combination of colors you want!</p>
<p>So this gives us a <code>H</code> in green, over black. Next letter: <code>e</code>.</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    hlt
</code></pre>
<p>Lower case <code>e</code> is <code>65</code> in ASCII, at least, in hexadecimal. And <code>02</code> is our same
color code. But you’ll notice that the memory location is different.</p>
<p>Okay, so we copied four hexadecimal digits into memory, right? For our <code>H</code>.
<code>0248</code>. A hexadecimal digit has sixteen values, which is 4 bits (for example, <code>0xf</code>
would be represented in bits as <code>1111</code>). Two of them make 8 bits, i.e. one byte.
Since we need half a word for the colors (<code>02</code>), and half a word for the <code>H</code> (<code>48</code>),
that’s one word in total (or two bytes). Each place that the memory address points
to can hold one byte (a.k.a. 8 bits or half a word). Hence, if our first memory
position is at <code>0</code>, the second letter will start at <code>2</code>.</p>
<blockquote>
<p>You might be wondering, &quot;If we're in 32 bit mode, isn't a word 32 bits?&quot; since sometimes ‘word’ is used to talk about native CPU register size. Well, the ‘word’ keyword in the context of x86_64 assembly specifically refers to 2 bytes, or 16 bits of data.  This is for reasons of backwards compatibility.</p>
</blockquote>
<p>This math gets easier the more often you do it. And we won’t be doing <em>that</em> much
more of it. There is a lot of working with hex numbers in operating systems work,
so you’ll get better as we practice.</p>
<p>With this, you should be able to get the rest of Hello, World. Go ahead and try
if you want: each letter needs to bump the location twice, and you need to look
up the letter’s number in hex.</p>
<p>If you don’t want to bother with all that, here’s the final code:</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    mov word [0xb8000], 0x0248 ; H
    mov word [0xb8002], 0x0265 ; e
    mov word [0xb8004], 0x026c ; l
    mov word [0xb8006], 0x026c ; l
    mov word [0xb8008], 0x026f ; o
    mov word [0xb800a], 0x022c ; ,
    mov word [0xb800c], 0x0220 ;
    mov word [0xb800e], 0x0277 ; w
    mov word [0xb8010], 0x026f ; o
    mov word [0xb8012], 0x0272 ; r
    mov word [0xb8014], 0x026c ; l
    mov word [0xb8016], 0x0264 ; d
    mov word [0xb8018], 0x0221 ; !
    hlt
</code></pre>
<p>Finally, now that we’ve got all of the code working, we can assemble our
<code>boot.asm</code> file with <code>nasm</code>, just like we did with the <code>multiboot_header.asm</code>
file:</p>
<pre><code class="language-bash">$ nasm -f elf64 boot.asm
</code></pre>
<p>This will produce a <code>boot.o</code> file. We’re almost ready to go!</p>
<h2><a class="header" href="#linking-it-together" id="linking-it-together">Linking it together</a></h2>
<p>Okay! So we have two different <code>.o</code> files: <code>multiboot_header.o</code> and <code>boot.o</code>.
But what we need is <em>one</em> file with both of them. Our OS doesn’t have the
ability to do anything yet, let alone load itself in two parts somehow. We just
want one big binary file.</p>
<p>Enter ‘linking’. If you haven’t worked in a compiled language before, you
probably haven’t had to deal with linking before. Linking is how we’ll turn
these two files into a single output: by linking them together.</p>
<p>Open up a file called <code>linker.ld</code>and put this in it:</p>
<pre><code class="language-text">ENTRY(start)

SECTIONS {
    . = 1M;

    .boot :
    {
        /* ensure that the multiboot header is at the beginning */
        *(.multiboot_header)
    }

    .text :
    {
        *(.text)
    }
}
</code></pre>
<p>This is a ‘linker script’. It controls how our linker will combine these
files into the final output. Let’s take it bit-by-bit:</p>
<pre><code class="language-text">ENTRY(start)
</code></pre>
<p>This sets the ‘entry point’ for this executable. In our case, we called our
entry point by the name people use: <code>start</code>. Remember? In <code>boot.asm</code>? Same
name here.</p>
<pre><code class="language-text">SECTIONS {
</code></pre>
<p>Okay! I’ve been promising you that we’d talk about sections. Everything inside
of these curly braces is a section. We annotated parts of our code with
sections earlier, and here, in this part of the linker script, we will describe
each section by name and where it goes in the resulting output.</p>
<pre><code class="language-text">    . = 1M;
</code></pre>
<p>This line means that we will start putting sections at the one megabyte mark.
This is the conventional place to put a kernel, at least to start. Below one
megabyte is all kinds of memory-mapped stuff. Remember the VGA stuff? It
wouldn’t work if we mapped our kernel’s code to that part of memory... garbage
on the screen!</p>
<pre><code class="language-text">    .boot :
</code></pre>
<p>This will create a section named <code>boot</code>. And inside of it...</p>
<pre><code class="language-text">        *(.multiboot_header)
</code></pre>
<p>... goes every section named <code>multiboot_header</code>. Remember how we defined that
section in <code>multiboot_header.asm</code>? It’ll be here, at the start of the <code>boot</code>
section. That’s what we need for GRUB to see it.</p>
<pre><code class="language-text">    .text :
</code></pre>
<p>Next, we define a <code>text</code> section. The <code>text</code> section is where you put code.
And inside of it...</p>
<pre><code class="language-text">        *(.text)
</code></pre>
<p>... goes every section named <code>.text</code>. See how this is working? The syntax is a
bit weird, but it’s not too bad.</p>
<p>That’s it for our script! We can then use <code>ld</code> to link all of this stuff
together:</p>
<pre><code class="language-bash">$ ld --nmagic --output=kernel.bin --script=linker.ld multiboot_header.o boot.o
</code></pre>
<p>Recall that on Mac OS X you will want to use the linker we installed to
<code>~/opt</code> and not your system linker. For example, if you did not change any of
the defaults in the installation script, this linker will be located at
<code>$HOME/opt/bin/x86_64-pc-elf-ld</code>.</p>
<p>By running this command, we do a few things:</p>
<pre><code class="language-text">--nmagic
</code></pre>
<p>TODO: https://github.com/intermezzOS/book/issues/30</p>
<pre><code class="language-text">--output=kernel.bin
</code></pre>
<p>This sets the name of our output file. In our case, that’s <code>kernel.bin</code>. We’ll be using
this file in the next step. It’s our whole kernel!</p>
<pre><code class="language-text">--script=linker.ld
</code></pre>
<p>This is the linker script we just made.</p>
<pre><code class="language-text">multiboot_header.o boot.o
</code></pre>
<p>Finally, we pass all the <code>.o</code> files we want to link together.</p>
<p>That’s it! We’ve now got our kernel in the <code>kernel.bin</code> file. Next, we’re going to
make an ISO out of it, so that we can load it up in QEMU.</p>
<h1><a class="header" href="#making-an-iso" id="making-an-iso">Making an ISO</a></h1>
<p>Now that we have our <code>kernel.bin</code>, the next step is to make an ISO. Remember
compact discs? Well, by making an ISO file, we can both test our Hello World
kernel in QEMU, as well as running it on actual hardware!</p>
<p>To do this, we’re going to use a GRUB tool called <code>grub-mkrescue</code>. We have to
create a certain structure of files on disk, run the tool, and we’ll get an
<code>os.iso</code> file at the end.</p>
<p>Doing so is not very much work, but we need to make the files in the right
places. First, we need to make three directories:</p>
<pre><code class="language-bash">$ mkdir -p isofiles/boot/grub
</code></pre>
<p>The <code>-p</code> flag to <code>mkdir</code> will make the directory we specify, as well as any
‘parent’ directories, hence the <code>p</code>. In other words, this will make an
<code>isofiles</code> directory, with a <code>boot</code> directory inside, and a <code>grub</code> directory
inside of that.</p>
<p>Next, create a <code>grub.cfg</code> file inside of that <code>isofiles/boot/grub</code> directory,
and put this in it:</p>
<pre><code class="language-text">set timeout=0
set default=0

menuentry &quot;intermezzOS&quot; {
    multiboot2 /boot/kernel.bin
    boot
}
</code></pre>
<p>This file configures GRUB. Let’s talk about the <code>menuentry</code> block first.
GRUB lets us load up multiple different operating systems, and it usually does
this by displaying a menu of OS choices to the user when the machine boots. Each
<code>menuentry</code> section corresponds to one of these. We give it a name, in this
case, <code>intermezzOS</code>, and then a little script to tell it what to do. First,
we use the <code>multiboot2</code> command to point at our kernel file. In this case,
that location is <code>/boot/kernel.bin</code>. Remember how we made a <code>boot</code> directory
inside of <code>isofiles</code>? Since we’re making the ISO out of the <code>isofiles</code> directory,
everything inside of it is at the root of our ISO. Hence <code>/boot</code>.</p>
<p>Let’s copy our <code>kernel.bin</code> file there now:</p>
<pre><code class="language-bash">$ cp kernel.bin isofiles/boot/
</code></pre>
<p>Finally, the <code>boot</code> command says “that’s all the configuration we need to do,
boot it up.“</p>
<p>But what about those <code>timeout</code> and <code>default</code> settings? Well, the <code>default</code> setting
controls which <code>menuentry</code> we want to be the default. The numbers start at zero,
and since we only have that one, we set it as the default. When GRUB starts, it
will wait for <code>timeout</code> seconds, and then choose the <code>default</code> option if the user
didn’t pick a different one. Since we only have one option here, we just set it to
zero, so it will start up right away.</p>
<p>The final layout should look like this:</p>
<pre><code class="language-text">isofiles/
└── boot
    ├── grub
    │   └── grub.cfg
    └── kernel.bin
</code></pre>
<p>Using <code>grub-mkrescue</code> is easy. We run this command:</p>
<pre><code class="language-bash">$ grub-mkrescue -o os.iso isofiles
</code></pre>
<p>The <code>-o</code> flag controls the <em>o</em>utput filename, which we choose to be <code>os.iso</code>.
And then we pass it the directory to make the ISO out of, which is the
<code>isofiles</code> directory we just set up.</p>
<p>After this, you have an <code>os.iso</code> file with our teeny kernel on it. You could
burn this to a USB stick or CD and run it on an actual computer if you wanted
to! But doing so would be really annoying during development. So in the next
section, we’ll use an emulator, QEMU, to run the ISO file on our development
machine.</p>
<h1><a class="header" href="#running-in-qemu" id="running-in-qemu">Running in QEMU</a></h1>
<p>Let’s actually run our kernel! To do this, we’ll use
<a href="http://www.qemu.org/">QEMU</a>, a full-system emulator. Using QEMU is
fairly straightfoward:</p>
<pre><code class="language-bash">$ qemu-system-x86_64 -cdrom os.iso
</code></pre>
<p>Type it in, hit Enter, and you should see <code>Hello, world!</code> (To exit, hit
<kbd>Alt+2</kbd> and type <code>quit</code> in the console.)</p>
<img alt="hello world" class="center" src="assets/hello_world.png" />
<p>If it shows up for you too, congrats! If not, something may have gone
wrong. Double check that you followed the examples <em>exactly</em>. Maybe
you missed something, or made a mistake while copying things down.</p>
<p>Note all of this other stuff behind the Hello World message: this part may look
different, based on your version of GRUB, and also since we didn’t clear the
screen, everything from GRUB just stays as it is. We’ll write a function to do
that eventually...</p>
<p>Let’s talk about this command before we move on:</p>
<pre><code class="language-text">qemu-system-x86_64
</code></pre>
<p>We’re running the <code>x86_64</code> variant of QEMU. While we have a 32-bit kernel for
now, soon we’ll have a 64-bit one. And since things are backwards compatible,
this works just fine.</p>
<pre><code class="language-text">-cdrom os.iso
</code></pre>
<p>We’re going to start QEMU with a CD-ROM drive, and its contents are the
<code>os.iso</code> file we made.</p>
<p>That’s it! Here’s the thing, though: while that wasn’t <em>too</em> complicated, it
was a lot of steps. Each time we make a change, we have to go through all these
steps over again. In the next section, we’ll use Make to do all these steps for
us.</p>
<h1><a class="header" href="#automation-with-make" id="automation-with-make">Automation with Make</a></h1>
<p>Typing all of these commands out every time we want to build the project is
tiring and error-prone. It’s nice to be able to have a single command that
builds our entire project. To do this, we’ll use <code>make</code>. Make is a classic
bit of software that’s used for this purpose. At its core, <code>make</code> is fairly
simple:</p>
<ul>
<li>You create a file called <code>Makefile</code>.</li>
<li>In this file, you define <strong>rules</strong>. Rules are composed of three things:
<strong>targets</strong>, <strong>prerequisites</strong>, and <strong>commands</strong>.</li>
<li>Targets describe what you are trying to build.</li>
<li>Targets can depend on other targets being built before they can be built.
These are called ‘prerequisites’.</li>
<li>Commands describe what it takes to actually build the target.</li>
</ul>
<p>Let’s start off with a very straightforward rule. Specifically, the first step
that we did was to build the Multiboot header by running <code>nasm</code>. Let’s build a
<code>Makefile</code> that does this. Open a file called <code>Makefile</code> and put this in it:</p>
<pre><code class="language-makefile">multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm
</code></pre>
<p>It’s <em>very</em> important that that <code>nasm</code> line uses a tab to indent. It can’t be
spaces. It has to be a tab. Yay legacy software!</p>
<p>Let’s try to run it before we talk about the details:</p>
<pre><code class="language-bash">$ make
nasm -f elf64 multiboot_header.asm
$
</code></pre>
<p>If you see this output, success! Let’s talk about this syntax:</p>
<pre><code class="language-text">target: prerequisites
        command
</code></pre>
<p>The bit before the colon is called a ‘target’. That’s the thing we’re trying to
build. In this case, we want to create the <code>multiboot_header.o</code> file, so we name
our target after that.</p>
<p>After the colon comes the ‘prerequisites’. This is a list of other targets that must
be built for this target to be built. In this case, building <code>multiboot_header.o</code>
requires that we have a <code>multiboot_header.asm</code>. We have no rule describing how
to build this file but it existing is enough to satisfy the dependency.</p>
<p>Finally, on the next line, and indented by a tab, we have a ‘command’. This is the
shell command that you need to build the target.</p>
<p>Building <code>boot.o</code> is similar:</p>
<pre><code class="language-makefile">multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm
</code></pre>
<p>Let’s try to build it:</p>
<pre><code class="language-bash">$ make
make: ‘multiboot_header.o’ is up to date.
$
</code></pre>
<p>Wait a minute, what? There’s two things going on here. The first is that <code>make</code> will build
the first target that you list by default. So a simple <code>make</code> will not build <code>boot.o</code>. To
build it, we can pass <code>make</code> the target name:</p>
<pre><code class="language-bash">$ make boot.o
nasm -f elf64 boot.asm
</code></pre>
<p>Okay, so that worked. But what about this ‘is up to date’ bit?</p>
<p>By default, <code>make</code> will keep track of the last time you built a particular
target, and check the prerequisites’ last-modified-time against that time. If
the prerequisites haven’t been updated since the target was last built, then it
won’t re-execute the build command. This is a really powerful feature,
especially as we grow. You don’t want to force the entire project to re-build
just because you edited one file; it’s nicer to only re-build the bits that
interact with it directly. A lot of the skill of <code>make</code> is defining the right
targets to make this work out nicely.</p>
<p>It would be nice if we could build both things with one command, but as it
turns out, our next target, <code>kernel.bin</code>, relies on both of these <code>.o</code> files,
so let’s write it first:</p>
<pre><code class="language-makefile">multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm

kernel.bin: multiboot_header.o boot.o linker.ld
        ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>Let’s try building it:</p>
<pre><code class="language-bash">$ make kernel.bin
ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>Great! The <code>kernel.bin</code> target depends on <code>multiboot_header.o</code>, <code>boot.o</code>, and <code>linker.ld</code>. The
first two are the previous targets we defined, and <code>linker.ld</code> is a file on its own.</p>
<p>Let’s make <code>make</code> build the whole thing by default:</p>
<pre><code class="language-makefile">default: kernel.bin

multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm

kernel.bin: multiboot_header.o boot.o linker.ld
        ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>We can name targets whatever we want. In this case, <code>default</code> is a good
convention for the first rule, as it’s the default target. It relies on
the <code>kernel.bin</code> target, which means that we’ll build it, and as we previously
discussed, <code>kernel.bin</code> will build our two <code>.o</code>s.</p>
<p>Let’s try it out:</p>
<pre><code class="language-bash">$ make
make: Nothing to be done for ‘default’.
</code></pre>
<p>We haven’t edited our files, so everything is built. Let’s modify one. Open up
<code>multiboot_header.asm</code> in your editor, save it, and then run <code>make</code>:</p>
<pre><code class="language-bash">$ make
nasm -f elf64 multiboot_header.asm
ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
</code></pre>
<p>It re-built <code>multiboot_header.o</code>, and then <code>kernel.bin</code>. But it didn’t rebuild
<code>boot.o</code>, as we didn’t modify it at all.</p>
<p>Let’s add a new rule to build our iso. Rather than show the entire <code>Makefile</code>, I’m
going to start showing you what’s changed. First, we have to update our <code>default</code>
target, and then we have to write the new one:</p>
<pre><code class="language-makefile">default: os.iso

os.iso: kernel.bin grub.cfg
        mkdir -p isofiles/boot/grub
        cp grub.cfg isofiles/boot/grub
        cp kernel.bin isofiles/boot/
        grub-mkrescue -o os.iso isofiles
</code></pre>
<p>This is our first multi-command rule. <code>make</code> will execute all of the commands
that you list. In this case, to build the ISO, we need to create our <code>isofiles</code>
directory, and then copy <code>grub.cfg</code> and <code>kernel.bin</code> into the right place
inside of it. Finally, <code>grub-mkrescue</code> builds the ISO from that directory.</p>
<p>This rule assumes that <code>grub.cfg</code> is at our top-level directory, but it’s
currently in <code>isofiles/boot/grub</code> already. So let’s copy it out:</p>
<pre><code class="language-bash">$ cp isofiles/boot/grub/grub.cfg .
</code></pre>
<p>And now we can build:</p>
<pre><code class="language-bash">$ make
mkdir -p isofiles/boot/grub
cp grub.cfg isofiles/boot/grub
cp kernel.bin isofiles/boot/
grub-mkrescue -o os.iso isofiles
</code></pre>
<p>Sometimes, it’s nice to add targets which describe a semantic. In this case, building
the <code>os.iso</code> target is the same as building the project. So let’s say so:</p>
<pre><code class="language-makefile">default: build

build: os.iso
</code></pre>
<p>The default action is to build the project, and to build the project, we need to build
<code>os.iso</code>. But what about running it? Let’s add a rule for that:</p>
<pre><code class="language-makefile">default: run

run: os.iso
        qemu-system-x86_64 -cdrom os.iso
</code></pre>
<p>You can choose the default here: do you want the default to be build, or run? Here’s what
each looks like:</p>
<pre><code class="language-bash">$ make     # build is the default
$ make run
</code></pre>
<p>or</p>
<pre><code class="language-bash">$ make       # run is the default
$ make build
</code></pre>
<p>I prefer to make <code>run</code> the default.</p>
<p>Finally, there’s another useful common rule: <code>clean</code>. The <code>clean</code> rule should remove all
of the generated files, and allow us to do a full re-build. As such it’s a bunch of <code>rm</code>
statements:</p>
<pre><code class="language-makefile">clean:
        rm -f multiboot_header.o
        rm -f boot.o
        rm -f kernel.bin
        rm -rf isofiles
        rm -f os.iso
</code></pre>
<p>Now there's just one more wrinkle. We have four targets that aren't really files
on disk, they are just actions: <code>default</code>, <code>build</code>, <code>run</code> and <code>clean</code>. Remember
we said earlier that <code>make</code> decides whether or not to execute a command by
comparing the last time a target was built with the last-modified-time of its
prerequisites? Well, it determines the last time a target was built by looking
at the last-modified-time of the target file. If the target file doesn't exist,
then it's definitely out-of-date so the command will be run.</p>
<p>But what if we accidentally create a file called <code>clean</code>? It doesn't have any
prerequisites so it will always be up-to-date and the commands will never be
run! We need a way to tell <code>make</code> that this is a special target, it isn't really
a file on disk, it's an action that should always be executed. We can do this
with a magic built-in target called <code>.PHONY</code>:</p>
<pre><code class="language-makefile">.PHONY: default build run clean
</code></pre>
<p>Here’s our final <code>Makefile</code>:</p>
<pre><code class="language-makefile">default: run

.PHONY: default build run clean

multiboot_header.o: multiboot_header.asm
        nasm -f elf64 multiboot_header.asm

boot.o: boot.asm
        nasm -f elf64 boot.asm

kernel.bin: multiboot_header.o boot.o linker.ld
        ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o

os.iso: kernel.bin grub.cfg
        mkdir -p isofiles/boot/grub
        cp grub.cfg isofiles/boot/grub
        cp kernel.bin isofiles/boot/
        grub-mkrescue -o os.iso isofiles

build: os.iso

run: os.iso
        qemu-system-x86_64 -cdrom os.iso

clean:
        rm -f multiboot_header.o
        rm -f boot.o
        rm -f kernel.bin
        rm -rf isofiles
        rm -f os.iso
</code></pre>
<p>You'll notice that there is a fair amount of repetition here. At first, that's
pretty okay: make can be a bit hard to understand, and while it has features
that let you de-duplicate things, they can also get unreadable really fast.</p>
<h2><a class="header" href="#creating-a-build-subdirectory" id="creating-a-build-subdirectory">Creating a build subdirectory</a></h2>
<p>Here's one example of a tweak we can do: <code>nasm</code> supports a <code>-o</code> flag, which
controls the name of the output file. We can use this to build <em>everything</em> in
a <code>build</code> subdirectory. This is nice for a number of reasons, but one of the
simplest is that all of our generated files will go in a single directory,
which means that it’s much easier to keep track of them: they’ll all be in one
place.</p>
<p>Let’s make some changes: More specifically, three of them:</p>
<pre><code class="language-makefile">build/multiboot_header.o: multiboot_header.asm
        mkdir -p build
        nasm -f elf64 multiboot_header.asm -o build/multiboot_header.o
</code></pre>
<p>The first one is the name of the rule. We have to add a <code>build/</code> in front of
the filename. This is because we’re going to be putting this file in that
directory now.</p>
<p>Second, we added another line: <code>mkdir</code>. We used <code>-p</code> to make directories
before, but in this case, the purpose of the flag is to not throw an error
if the directory already exists. We need to try to make this directory
when we build so that we can put our <code>.o</code> file in it!</p>
<p>Finally, we add the <code>-o</code> flag to <code>nasm</code>. This will create our output file in
that <code>build</code> directory, rather than in the current one.</p>
<p>With that, we’re ready to modify <code>boot.o</code> as well:</p>
<pre><code class="language-makefile">build/boot.o: boot.asm
        mkdir -p build
        nasm -f elf64 boot.asm -o build/boot.o
</code></pre>
<p>These changes are the same, just with <code>boot</code> instead of <code>multiboot_header</code>.</p>
<p>Next up: <code>kernel.bin</code>:</p>
<pre><code class="language-makefile">build/kernel.bin: build/multiboot_header.o build/boot.o linker.ld
        ld -n -o build/kernel.bin -T linker.ld build/multiboot_header.o build/boot.o
</code></pre>
<p>We add <code>build</code> in no fewer than <em>six</em> places. Whew! At least it’s
straightforward.</p>
<pre><code class="language-makefile">build/os.iso: build/kernel.bin grub.cfg
        mkdir -p build/isofiles/boot/grub
        cp grub.cfg build/isofiles/boot/grub
        cp build/kernel.bin build/isofiles/boot/
        grub-mkrescue -o build/os.iso build/isofiles
</code></pre>
<p>Seeing a pattern yet? More prefixing.</p>
<pre><code class="language-makefile">run: build/os.iso
        qemu-system-x86_64 -cdrom build/os.iso
</code></pre>
<p>... and here as well.</p>
<pre><code class="language-makefile">clean:
        rm -rf build
</code></pre>
<p>Now some payoff! To get rid of our generated files, all we have to do is <code>rm</code>
our <code>build</code> directory. Much easier.</p>
<p>Here’s our final version:</p>
<pre><code class="language-makefile">default: run

.PHONY: default build run clean

build/multiboot_header.o: multiboot_header.asm
        mkdir -p build
        nasm -f elf64 multiboot_header.asm -o build/multiboot_header.o

build/boot.o: boot.asm
        mkdir -p build
        nasm -f elf64 boot.asm -o build/boot.o

build/kernel.bin: build/multiboot_header.o build/boot.o linker.ld
        ld -n -o build/kernel.bin -T linker.ld build/multiboot_header.o build/boot.o

build/os.iso: build/kernel.bin grub.cfg
        mkdir -p build/isofiles/boot/grub
        cp grub.cfg build/isofiles/boot/grub
        cp build/kernel.bin build/isofiles/boot/
        grub-mkrescue -o build/os.iso build/isofiles

run: build/os.iso
        qemu-system-x86_64 -cdrom build/os.iso

build: build/os.iso

clean:
        rm -rf build
</code></pre>
<p>We can go further, and eventually, we will. But this is good enough for now.
Like I said, there’s a fine balance between keeping it <a href="https://en.wikipedia.org/wiki/Dont_repeat_yourself">DRY</a> and making it
non-understandable.</p>
<p>Luckily, we’ll only be using Make for these assembly files. Rust has its own
build tool, Cargo, that we’ll integrate with Make. It’s a lot easier to use.</p>
<h1><a class="header" href="#transitioning-to-long-mode" id="transitioning-to-long-mode">Transitioning to Long Mode</a></h1>
<p>We now have our little kernel in protected mode. But we’re making a 64-bit
kernel here, so we need to transition from protected mode to ‘long mode’.
This takes a sequence of steps. After this, the next step is calling into
Rust code!</p>
<h1><a class="header" href="#paging" id="paging">Paging</a></h1>
<p>At the end of the last chapter, we did a lot of work that wasn’t actually
writing kernel code. So let’s review what we’re up to:</p>
<ol>
<li>GRUB loaded our kernel, and started running it.</li>
<li>We’re currently running in ‘protected mode’, a 32-bit environment.</li>
<li>We want to transition to ‘long mode’, the 64-bit environment.</li>
<li>In order to do that, we have to do some work.</li>
</ol>
<p>We’re on step four. More specifically, here’s what we have to do:</p>
<ol>
<li>Set up something called ‘paging’.</li>
<li>Set up something called a ‘GDT’.</li>
<li>Jump to long mode.</li>
</ol>
<p>This section covers step one. The next two will cover the other two steps.
Afterwards, we’ll be ready to stop writing assembly and start writing Rust!</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>There’s something we’re going to skip here, which we’d want to do in a more
serious kernel: check to make sure that our hardware can actually do this!
We’re going to just assume that our ‘hardware’ can run in 64-bit mode, because
we’re running our OS in QEMU, which supports all of these operations. But if
we were to run our OS on a real 32-bit computer, it would end up crashing.
We could check that it’s possible, and then print a nice error message
instead. But, we won’t cover that here. It’s not particularly interesting, and
we know that it will never fail. But it might be something you want to explore
on your own, for extra credit.</p>
</blockquote>
<h2><a class="header" href="#paging-1" id="paging-1">Paging</a></h2>
<p>So, step one: set up ‘paging’. What is paging? Paging is a way of managing
memory. Our computer has memory, and we can think of memory as being a big long
list of cells:</p>
<table><thead><tr><th>address</th><th>value</th></tr></thead><tbody>
<tr><td>0x00</td><td>0</td></tr>
<tr><td>0x01</td><td>0</td></tr>
<tr><td>0x02</td><td>0</td></tr>
<tr><td>0x03</td><td>0</td></tr>
<tr><td>0x04</td><td>0</td></tr>
<tr><td>...</td><td></td></tr>
</tbody></table>
<p>Each location in memory has an address, and we can use the address to
distinguish between the cells: the value at cell zero, the value at cell ten.</p>
<p>But how many cells are there? This question has two answers: The first answer is
how much physical memory (RAM) do we have in our machine? This will vary per machine.
My machine has 8 gigabytes of memory or 8,589,934,592 bytes. But maybe your machine
has 4 gigabytes of memory, or sixteen gigabytes of memory.</p>
<p>The second answer to how many cells there are is how many addresses can be used
to refer to cells of memory? To answer that we need to figure out how many different
unique numbers we can make. In 64-bit mode, we can create as many addresses as can be
expressed by a 64-bit number. So that means we can make addresses from zero to
(2^64) - 1. That’s 18,446,744,073,709,551,616 addresses! We sometimes refer to a
sequence of addresses as an ‘address space’, so we might say “The full 64-bit address
space has 2^64 addresses.”</p>
<p>So now we have an imbalance. We have only roughly 8.5 billion actual physical memory
slots in an 8GB machine but quintillions of possible addresses we can make.</p>
<p>How can we resolve this imbalance? We don't want to be able to address memory
that doesn't exist!</p>
<p>Here’s the strategy: we introduce two kinds of addresses: <em>physical</em> addresses
and <em>virtual</em> addresses. A physical address is the actual, real value of a
location in the physical RAM in the machine. A virtual address is an address
anywhere inside of our 64-bit address space: the full range. To bridge between
the two address spaces, we can map a given virtual address to a particular
physical address. So we might say something like “virtual address 0x044a maps to
the physical address 0x0011.” Software uses the virtual addresses, and the
hardware uses physical addresses.</p>
<p>Mapping each individual address would be extremely inefficient; we would need
to keep track of literally every memory address and where it points to.
Instead, we split up memory into chunks, also called ‘pages’, and then map each
page to an equal sized chunk of physical memory.</p>
<blockquote>
<p><strong>By the way...</strong>
In the future we'll be using paging to help us implement something called
&quot;virtual memory&quot;. Besides helping us always be able to map a 64-bit number to
a real place in physical memory, &quot;virtual memory&quot; is useful for other reasons.
These reasons don't really come into play at this point, so we'll hold off on
discussing them. For now, it's just important to know that we need paging to
enter 64-bit long mode and that it's a good idea for many reasons including
helping us resolve the fact the we have way less actual memory than possible
addresses to refer to that memory.</p>
</blockquote>
<p>Paging is actually implemented by a part of the CPU called an ‘MMU’, for ‘memory
management unit’. The MMU will translate virtual addresses into
their respective physical addresses automatically; we can write all of our
software with virtual addresses only. The MMU does this with a data structure
called a ‘page table’. As an operating system, we load up the page table with a
certain data structure, and then tell the CPU to enable paging. This is the task
ahead of us; it’s required to set up paging before we transition to long mode.</p>
<p>How should we do our mapping of physical to virtual addresses? You can make
this easy, or complex, and it depends on exactly what you want your OS to
be good at. Some strategies are better than others, depending on the kinds of
programs you expect to be running. We’re going to keep it simple, and use a
strategy called ‘identity mapping’. This means that every virtual address will
map to a physical address of the same number. Nothing fancy.</p>
<p>Let’s talk more about the page table. In long mode, the page table is four
levels deep, and each page is 4096 bytes in size. What do I mean by levels?
Here are the official names:</p>
<ul>
<li>the Page-Map Level-4 Table (PML4),</li>
<li>the Page-Directory Pointer Table (PDP),</li>
<li>the Page-Directory Table (PD),</li>
<li>and the Page Table (PT).</li>
</ul>
<p>I’ve most commonly heard them referred to as a “level x page table”, where <code>x</code>
goes from four to one. So the PML4 is a “level four page table,” and the PT is
a “level one page table.” They’re called ‘levels’ because they decend in order:
each entry in a level 4 page table points to a level 3 page table entry. Each
level 3 page table entry points at a level 2 page table entry, and each level 2
page table entry points at a level 1 page table entry. That entry then contains
the address. Whew! To get started, we only need one entry of each table.</p>
<h2><a class="header" href="#creating-the-page-table" id="creating-the-page-table">Creating the page table</a></h2>
<p>So here’s the strategy: create a single entry of each of these tables, then
point them at each other in the correct way, then tell the CPU that paging
should be enabled.</p>
<h3><a class="header" href="#how-many-tables" id="how-many-tables">How many tables?</a></h3>
<p>The number of tables we need depends on how big we make each page. The bigger
each page, the fewer pages fit into the virtual address space, so the fewer
tables we need. How to choose a page size is the kind of detail we don't need to
worry about for now. We're just going to go for 2 MiB pages, which means we only
need three tables: we won't need a level 1 page table.</p>
<h3><a class="header" href="#creating-page-table-entries" id="creating-page-table-entries">Creating page table entries</a></h3>
<p>To create space for these page table entries, open up <code>boot.asm</code> and add these
lines at the bottom:</p>
<pre><code class="language-x86asm">section .bss

align 4096

p4_table:
    resb 4096
p3_table:
    resb 4096
p2_table:
    resb 4096
</code></pre>
<p>We introduce a new section, ‘bss’. It stands for ‘block started by symbol’, and
was introduced in the 1950s. The name doesn’t make much sense anymore, but the
reason we use it is because of its behavior: entries in the bss section are
automatically set to zero by the linker. This is useful, as we only want certain
bits set to 1, and most of them set to zero.</p>
<p>The <code>resb</code> directive reserves bytes; we want to reserve space for each entry.</p>
<p>The <code>align</code> directive makes sure that we’ve aligned our tables properly. We
haven’t talked much about alignment yet: the idea is that the addresses here
will be set to a multiple of 4096, hence ‘aligned’ to 4096 byte chunks. We’ll
eventually talk more about alignment and why it’s important, but it doesn’t
matter a ton right now.</p>
<p>After this has been added, we have a single valid entry for each level.
However, because our page four entry is all zeroes, we have no valid pages.
That’s not super useful. Let’s set things up properly.</p>
<h3><a class="header" href="#pointing-the-entries-at-each-other" id="pointing-the-entries-at-each-other">Pointing the entries at each other</a></h3>
<p>In order to do this setup, we need to write some more assembly code! Open up
<code>boot.asm</code>. You can either leave in printing code, or remove it. If you do leave
it in, add this code before it: that way, if you see your message print out, you
know it ran successfully.</p>
<pre><code class="language-x86asm">global start

section .text
bits 32
start:
    ; Point the first entry of the level 4 page table to the first entry in the
    ; p3 table
    mov eax, p3_table
    or eax, 0b11
    mov dword [p4_table + 0], eax
</code></pre>
<p>If you recall, <code>;</code> are comments. Leaving yourself excessive comments in assembly
files is a good idea. Let’s go over each of these lines:</p>
<pre><code class="language-x86asm">    mov eax, p3_table
</code></pre>
<p>This copies the contents of the first third-level page table entry into the
<code>eax</code> register. We need to do this because of the next line:</p>
<pre><code class="language-x86asm">    or eax, 0b11
</code></pre>
<p>We take the contents of <code>eax</code> and <code>or</code> it with <code>0b11</code>, the result is written in <code>eax</code>. First, let’s talk about
<em>what</em> this does, and then we’ll talk about <em>why</em> we want to do it.</p>
<p>When dealing with binary, <code>or</code> is an operation that returns <code>1</code> if either value
is <code>1</code>, and <code>0</code> if both are <code>0</code>. In other words, if <code>a</code> and <code>b</code> are a single
binary digit:</p>
<table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>a</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>b</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>or a b</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
</tbody></table>
<p>You’ll see charts like this a lot when talking about binary stuff. You can read
this chart from top to bottom, each column is a case. So the first column says
“if <code>a</code> is zero and <code>b</code> is zero, <code>or a b</code> will be zero.” The second column says
“if <code>a</code> is one and <code>b</code> is zero, <code>or a b</code> will be one.” And so on.</p>
<p>So when we <code>or</code> with <code>0b11</code>, it means that the first two bits will be set to
one, leaving the rest as they were.</p>
<p>Okay, so now we know <em>what</em> we are doing, but <em>why</em>? Each entry in a page table
contains an address, but it also contains metadata about that page. The first
two bits are the ‘present bit’ and the ‘writable bit’. By setting the first bit,
we say “this page is currently in memory,” and by setting the second, we say
“this page is allowed to be written to.” There are a number of other settings we
can change this way, but they’re not important for now.</p>
<blockquote>
<p><strong>By the way...</strong></p>
<p>You might be wondering, if the entry in the page table is an address, how can
we use some of the bits of that address to store metadata without messing up
the address? Remember that we used the <code>align</code> directive to make sure that the
page tables all have addresses that are multiples of 4096. That means that the
CPU can assume that the first 12 bits of all the addresses are zero. If
they're always implicitly zero, we can use them to store metadata without
changing the address.</p>
</blockquote>
<p>Now that we have an entry set up properly, the next line is of interest:</p>
<pre><code class="language-x86asm">    mov dword [p4_table + 0], eax
</code></pre>
<p>Another <code>mov</code> instruction, but this time, copying <code>eax</code>, where we’ve been
setting things up, into... something in brackets. <code>[]</code> means, “I will be giving
you an address between the brackets. Please do something at the place this
address points.” In other words, <code>[]</code> is like a dereference operator.</p>
<p>Now, the address we’ve put is kind of funny looking: <code>p4_table + 0</code>. What’s up
with that <code>+ 0</code>? It’s not strictly needed: adding zero to something keeps it the
same. However, it’s intended to convey to the reader that we’re accessing the
zeroth entry in the page table. We’re about to see some more code later where we
will do something other than add zero, and so putting it here makes our code
look more symmetric overall. If you don’t like this style, you don’t have to put
the zero.</p>
<p>These few lines form the core of how we’re setting up these page tables. We’re
going to do the same thing over again, with slight variations.</p>
<p>Here’s the full thing again:</p>
<pre><code class="language-x86asm">    ; Point the first entry of the level 4 page table to the first entry in the
    ; p3 table
    mov eax, p3_table
    or eax, 0b11 ;
    mov dword [p4_table + 0], eax
</code></pre>
<p>Once you feel like you’ve got a handle on that, let’s move on to pointing the
page three table to the page two table!</p>
<pre><code class="language-x86asm">    ; Point the first entry of the level 3 page table to the first entry in the
    ; p2 table
    mov eax, p2_table
    or eax, 0b11
    mov dword [p3_table + 0], eax
</code></pre>
<p>The code is the same as above, but with <code>p2_table</code> and <code>p3_table</code> instead of
<code>p3_table</code> and <code>p4_table</code>. Nothing more than that.</p>
<p>We have one last thing to do: set up the level two page table to have valid
references to pages. We’re going to do something we haven’t done yet in
assembly: write a loop!</p>
<p>Here’s the basic outline of loop in assembly:</p>
<ul>
<li>Create a counter variable to track how many times we’ve looped</li>
<li>make a label to define where the loop starts</li>
<li>do the body of the loop</li>
<li>add one to our counter</li>
<li>check to see if our counter is equal to the number of times we want to loop</li>
<li>if it’s not, jump back to the top of the loop</li>
<li>if it is, we’re done</li>
</ul>
<p>It’s a little more detail-oriented than loops in other languages. Usually, you
have curly braces or indentation to indicate that the body of the loop is
separate, but we don’t have any of those things here. We also have to write the
code to increment the counter, and check if we’re done. Lots of little fiddly
bits. But that’s the nature of what we’re doing!</p>
<p>Let’s get to it!</p>
<pre><code class="language-x86asm">    ; point each page table level two entry to a page
    mov ecx, 0         ; counter variable
</code></pre>
<p>In order to write a loop, we need a counter. <code>ecx</code> is the usual loop counter
register, that’s what the <code>c</code> stands for: counter. We also have a comment
indicating what we’re doing in this part of the code.</p>
<p>Next, we need to make a new label:</p>
<pre><code class="language-x86asm">.map_p2_table:
</code></pre>
<p>As we mentioned above, this is where we will loop back to when the loop
continues.</p>
<pre><code class="language-x86asm">    mov eax, 0x200000  ; 2MiB
</code></pre>
<p>We’re going to store 0x200000 in <code>eax</code>, or 2,097,152 which is equivalent to 2 MiB. 
Here’s the reason: each page is two megabytes in size. So in order to get the 
right memory location, we will multiply the number of the loop counter by 0x200000:</p>
<table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>counter</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr>
<tr><td>0x200000</td><td>0x200000</td><td>0x200000</td><td>0x200000</td><td>0x200000</td><td>0x020000</td></tr>
<tr><td>multiplied</td><td>0</td><td>0x200000</td><td>0x400000</td><td>0x600000</td><td>0x800000</td></tr>
</tbody></table>
<p>And so on. So our pages will be all next to each other, and 2,097,152 bytes in
size.</p>
<pre><code class="language-x86asm">    mul ecx
</code></pre>
<p>Here’s that multiplication! <code>mul</code> takes just one argument, which in this case
is our <code>ecx</code> counter, and multiplies that by <code>eax</code>, storing the result in
<code>eax</code>. This will be the location of the next page.</p>
<pre><code class="language-x86asm">    or eax, 0b10000011
</code></pre>
<p>Next up, our friend <code>or</code>. Here, we don’t just or <code>0b11</code>: we’re also setting
another bit. This extra <code>1</code> is a ‘huge page’ bit, meaning that the pages are
2,097,152 bytes. Without this bit, we’d have 4KiB pages instead of 2MiB pages.</p>
<pre><code class="language-x86asm">    mov [p2_table + ecx * 8], eax
</code></pre>
<p>Just like before, we are now writing the value in <code>eax</code> to a location. But
instead of it being just <code>p2_table + 0</code>, we’re adding <code>ecx * 8</code>. Remember, <code>ecx</code>
is our loop counter. Each entry is eight bytes in size, so we need to multiply
the counter by eight, and then add it to <code>p2_table</code>. Let’s take a closer look:
let’s assume <code>p2_table</code> is zero, to make the math easier:</p>
<table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>p2_table</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>ecx</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr>
<tr><td>ecx * 8</td><td>0</td><td>8</td><td>16</td><td>24</td><td>32</td></tr>
<tr><td>p2_table + ecx * 8</td><td>0</td><td>8</td><td>16</td><td>24</td><td>32</td></tr>
</tbody></table>
<p>We skip eight spaces each time, so we have room for all eight bytes of the page
table entry.</p>
<p>That’s the body of the loop! Now we need to see if we need to keep looping or
not:</p>
<pre><code class="language-x86asm">    inc ecx
    cmp ecx, 512
    jne .map_p2_table
</code></pre>
<p>The <code>inc</code> instruction increments the register it’s given by one. <code>ecx</code> is our
loop counter, so we’re adding to it. Then, we ‘compare’ with <code>cmp</code>. We’re
comparing <code>ecx</code> with 512: we want to map 512 page entries overall. The page
table is 4096 bytes, each entry is 8 bytes, so that means there are 512 entries.
This will give us 512 * 2 mebibytes: one gibibyte of memory. It’s also why we
wrote the loop: writing out 512 entries by hand is possible, theoretically, but
is not fun. Let’s make the computer do the math for us.</p>
<p>The <code>jne</code> instruction is short for ‘jump if not equal’. It checks the result of
the <code>cmp</code>, and if the comparison says ‘not equal’, it will jump to the label
we’ve defined. <code>map_p2_table</code> points to the top of the loop.</p>
<p>That’s it! We’ve written our loop and mapped our second-level page table. Here’s
the full code of the loop:</p>
<pre><code class="language-x86asm">    ; point each page table level two entry to a page
    mov ecx, 0         ; counter variable
.map_p2_table:
    mov eax, 0x200000  ; 2MiB
    mul ecx
    or eax, 0b10000011
    mov [p2_table + ecx * 8], eax

    inc ecx
    cmp ecx, 512
    jne .map_p2_table
</code></pre>
<p>And, with this, we’ve now fully mapped our page table! We’re one step closer to
being in long mode. Here’s the full code, all in one place:</p>
<pre><code class="language-x86asm">    ; Point the first entry of the level 4 page table to the first entry in the
    ; p3 table
    mov eax, p3_table
    or eax, 0b11 ;
    mov dword [p4_table + 0], eax

    ; Point the first entry of the level 3 page table to the first entry in the
    ; p2 table
    mov eax, p2_table
    or eax, 0b11
    mov dword [p3_table + 0], eax

    ; point each page table level two entry to a page
    mov ecx, 0         ; counter variable
.map_p2_table:
    mov eax, 0x200000  ; 2MiB
    mul ecx
    or eax, 0b10000011
    mov [p2_table + ecx * 8], eax

    inc ecx
    cmp ecx, 512
    jne .map_p2_table
</code></pre>
<p>Now that we’ve done this, we have a valid initial page table. Time to enable paging!</p>
<h3><a class="header" href="#enable-paging" id="enable-paging">Enable paging</a></h3>
<p>Now that we have a valid page table, we need to inform the hardware about it.
Here’s the steps we need to take:</p>
<ul>
<li>We have to put the address of the level four page table in a special register</li>
<li>enable ‘physical address extension’</li>
<li>set the ‘long mode bit’</li>
<li>enable paging</li>
</ul>
<p>These four steps are not particularly interesting, but we have to do them.
First, let’s do the first step:</p>
<pre><code class="language-x86asm">    ; move page table address to cr3
    mov eax, p4_table
    mov cr3, eax
</code></pre>
<p>So, this might seem a bit redundant: if we put <code>p4_table</code> into <code>eax</code>, and then
put <code>eax</code> into <code>cr3</code>, why not just put <code>p4_table</code> into <code>cr3</code>? As it turns out,
<code>cr3</code> is a special register, called a ‘control register’, hence the <code>cr</code>. The
<code>cr</code> registers are special: they control how the CPU actually works. In our
case, the <code>cr3</code> register needs to hold the location of the page table.</p>
<p>Because it’s a special register, it has some restrictions, and one of those is
that when you <code>mov</code> to <code>cr3</code>, it has to be from another register. So we need the
first <code>mov</code> to set <code>p4_table</code> in a register before we can set <code>cr3</code>.</p>
<p>Step one: done!</p>
<p>Next, enabling ‘physical address extension’:</p>
<pre><code class="language-x86asm">    ; enable PAE
    mov eax, cr4
    or eax, 1 &lt;&lt; 5
    mov cr4, eax
</code></pre>
<p>In order to set PAE, we need to take the value in the <code>cr4</code> register and
modify it. So first, we <code>mov</code> it into <code>eax</code>, then we use <code>or</code> to change the
value. What about <code>1 &lt;&lt; 5</code>? The <code>&lt;&lt;</code> is a ‘left shift’. It might be easier to
show you with a table:</p>
<table><thead><tr><th></th><th>value</th></tr></thead><tbody>
<tr><td>1</td><td>000001</td></tr>
<tr><td>&lt;&lt; 1</td><td>000010</td></tr>
<tr><td>&lt;&lt; 2</td><td>000100</td></tr>
<tr><td>&lt;&lt; 3</td><td>001000</td></tr>
<tr><td>&lt;&lt; 4</td><td>010000</td></tr>
<tr><td>&lt;&lt; 5</td><td>100000</td></tr>
</tbody></table>
<p>See how the 1 moves left? So <code>1 &lt;&lt; 5</code> is <code>100000</code> (or 2^5 if you like maths; incidentally 1&lt;&lt;n = 2^n). If you only need to set one
bit, this can be easier than writing out <code>100000</code> itself, as you don’t need to
count the zeroes.</p>
<p>After we modify <code>eax</code> to have this bit set, we <code>mov</code> the value back into <code>cr4</code>.
PAE has been set! Why is this what you need to do? It just is. The details are
not really in the scope of this tutorial.</p>
<p>Okay, so we have step two done. Time for step three: setting the long mode bit:</p>
<pre><code class="language-x86asm">    ; set the long mode bit
    mov ecx, 0xC0000080
    rdmsr
    or eax, 1 &lt;&lt; 8
    wrmsr
</code></pre>
<p>The <code>rdmsr</code> and <code>wrmsr</code> instructions read and write to a ‘model specific
register’, hence <code>msr</code>. This is just what you have to do to set this up. Again,
we won’t get into too much detail, as it’s not very interesting. Boilerplate.</p>
<p>Finally we are all ready to enable paging!</p>
<pre><code class="language-x86asm">    ; enable paging
    mov eax, cr0
    or eax, 1 &lt;&lt; 31
    or eax, 1 &lt;&lt; 16
    mov cr0, eax
</code></pre>
<p><code>cr0</code> is the register we need to modify. We do the usual “move to <code>eax</code>, set
some bits, move back to the register” pattern. In this case, we set bit 31 and
bit 16.</p>
<p>Once we’ve set these bits, we’re done! Here’s the full code listing:</p>
<pre><code class="language-x86asm">    ; move page table address to cr3
    mov eax, p4_table
    mov cr3, eax

    ; enable PAE
    mov eax, cr4
    or eax, 1 &lt;&lt; 5
    mov cr4, eax

    ; set the long mode bit
    mov ecx, 0xC0000080
    rdmsr
    or eax, 1 &lt;&lt; 8
    wrmsr

    ; enable paging
    mov eax, cr0
    or eax, 1 &lt;&lt; 31
    or eax, 1 &lt;&lt; 16
    mov cr0, eax
</code></pre>
<h2><a class="header" href="#-are-we-in-long-mode-yet" id="-are-we-in-long-mode-yet">... are we in long mode yet?</a></h2>
<p>So, <em>technically</em> after paging is enabled, we are in long mode. But we’re not
in <em>real</em> long mode; we’re in a special compatibility mode. To get to real long
mode, we need a data structure called a ‘global descriptor table’. Read the next
section to find out how to make one of these.</p>
<h1><a class="header" href="#setting-up-a-gdt" id="setting-up-a-gdt">Setting up a GDT</a></h1>
<p>We’re so close! We’re currently in long mode, but not ‘real’ long mode. We need
to go from this ‘compatibility mode’ to honest-to-goodness long mode. To do
this, we need to set up a ‘global descriptor table’.</p>
<p>This table, also known as a GDT, is kind of vestigial. The GDT is used for a
style of memory handling called ‘segmentation’, which is in contrast to the
paging model that we just set up. Even though we’re not using segmentation,
however, we’re still required to have a valid GDT. Such is life.</p>
<p>So let’s set up a minimal GDT. Our GDT will have three entries:</p>
<ul>
<li>a ‘zero entry’</li>
<li>a ‘code segment’</li>
<li>a ‘data segment’</li>
</ul>
<p>If we were going to be using the GDT for real stuff, it could have a number
of code and data segment entries. But we need at least one of each to have a
minimum viable table, so let’s get to it!</p>
<h2><a class="header" href="#the-zero-entry" id="the-zero-entry">The Zero entry</a></h2>
<p>The first entry in the GDT is special: it needs to be a zero value. Add this
to the bottom of <code>boot.asm</code>:</p>
<pre><code class="language-x86asm">section .rodata
gdt64:
    dq 0
</code></pre>
<p>We have a new section: <code>rodata</code>. This stands for ‘read only data’, and since
we’re not going to modify our GDT, having it be read-only is a good idea.</p>
<p>Next, we have a label: <code>gdt64</code>. We’ll use this label later, to tell the hardware
where our GDT is located.</p>
<p>Finally, <code>dq 0</code>. This is ‘define quad-word’, in other words, a 64-bit value.
Given that it’s a zero entry, it shouldn’t be too surprising that the value of
this entry is zero!</p>
<p>That’s all there is to it.</p>
<h2><a class="header" href="#setting-up-a-code-segment" id="setting-up-a-code-segment">Setting up a code segment</a></h2>
<p>Next, we need a code segment. Add this below the <code>dq 0</code>:</p>
<pre><code class="language-x86asm">.code: equ $ - gdt64
    dq (1&lt;&lt;44) | (1&lt;&lt;47) | (1&lt;&lt;41) | (1&lt;&lt;43) | (1&lt;&lt;53)
</code></pre>
<p>Let's talk about the <code>dq</code> line first. If you recall from the last section,
<code>1&lt;&lt;44</code> means ‘left shift one 44 places’, which sets the 44th bit. But what
about <code>|</code>? This means <code>or</code>. So, if we <code>or</code> a bunch of these values together,
we’ll end up with a value that has the 44th, 47th, 41st, 43rd, and 53rd bit
set.</p>
<p>Why <code>|</code> and not <code>or</code>, like before? Well, here, we’re not running assembly
instructions: we’re defining some data. So there’s no instruction to execute, so
the language used is a bit different.</p>
<p>Finally, why these bits? Well, as we’ve seen with other table entries, each bit
has a meaning. Here’s a summary:</p>
<ul>
<li>44: ‘descriptor type’: This has to be <code>1</code> for code and data segments</li>
<li>47: ‘present’: This is set to <code>1</code> if the entry is valid</li>
<li>41: ‘read/write’: If this is a code segment, <code>1</code> means that it’s readable</li>
<li>43: ‘executable’: Set to <code>1</code> for code segments</li>
<li>53: ‘64-bit’: if this is a 64-bit GDT, this should be set</li>
</ul>
<p>That’s all we need for a valid code segment!</p>
<p>Oh, but let's not forget about the other line:</p>
<pre><code class="language-x86asm">.code: equ $ - gdt64
</code></pre>
<p>What's up with this? So, in a bit, we'll need to reference this entry somehow.
But we don't reference the entry by its address, we reference it by an offset.
If we needed just an address, we could use <code>code:</code>. But we can't, so we need
more. Also, note that period at the start, it's <code>.code:</code>. This tells the
assembler to scope this label under the last label that appeared, so we'll
say <code>gdt64.code</code> rather than just <code>code</code>. Some nice encapsulation.</p>
<p>So that's what's up with the label, but we still have this <code>equ $ - gdt64</code> bit.
<code>$</code> is the current position. So we're subtracting the address of <code>gdt64</code> from
the current position. Conveniently, that's the offset number we need for later:
how far is this segment past the start of the GDT. The <code>equ</code> sets the address
for the label; in other words, this line is saying &quot;set the <code>.code</code> label's
value to the current address minus the address of <code>gdt64</code>&quot;. Got it?</p>
<h2><a class="header" href="#setting-up-a-data-segment" id="setting-up-a-data-segment">Setting up a data segment</a></h2>
<p>Below the code segment, add this for a data segment:</p>
<pre><code class="language-x86asm">.data: equ $ - gdt64
    dq (1&lt;&lt;44) | (1&lt;&lt;47) | (1&lt;&lt;41)
</code></pre>
<p>We need less bits set for a data segment. But they’re ones we covered before.
The only difference is bit 41; for data segments, a <code>1</code> means that it’s
writable.</p>
<p>We also use the same trick again with the labels, calculating the offset with
<code>equ</code>.</p>
<h2><a class="header" href="#putting-it-all-together" id="putting-it-all-together">Putting it all together</a></h2>
<p>Here’s our whole GDT:</p>
<pre><code class="language-x86asm">section .rodata
gdt64:
    dq 0
.code: equ $ - gdt64
    dq (1&lt;&lt;44) | (1&lt;&lt;47) | (1&lt;&lt;41) | (1&lt;&lt;43) | (1&lt;&lt;53)
.data: equ $ - gdt64
    dq (1&lt;&lt;44) | (1&lt;&lt;47) | (1&lt;&lt;41)
</code></pre>
<p>We’re so close! Now, to tell the hardware about our GDT. There’s a special
assembly instruction for this: <code>lgdt</code>. But it doesn’t take the GDT itself; it
takes a special structure: two bytes for the length, and eight bytes for the
address. So we have to set <em>that</em> up.</p>
<p>Below these <code>dq</code>s, add this:</p>
<pre><code class="language-x86asm">.pointer:
    dw .pointer - gdt64 - 1
    dq gdt64
</code></pre>
<p>To calculate the length, we take the value of this new label, <code>pointer</code>, and
subtract the value of <code>gdt64</code>, and then subtract one more. We could calculate
this length manually, but if we do it this way, if we add another GDT entry for
some reason, it will automatically correct itself, which is nice.</p>
<p>The <code>dq</code> here has the address of our table. Straightforward.</p>
<h2><a class="header" href="#load-the-gdt" id="load-the-gdt">Load the GDT</a></h2>
<p>So! We’re finally ready to tell the hardware about our GDT. Add this line after
all of the paging stuff we did in the last chapter:</p>
<pre><code class="language-x86asm">    lgdt [gdt64.pointer]
</code></pre>
<p>We pass <code>lgdt</code> the value of our <code>pointer</code> label. <code>lgdt</code> stands for ‘load global
descriptor table’. That’s it!</p>
<p>We have all of the prerequisites done! In the next section, we will complete our
transition by jumping to long mode.</p>
<h1><a class="header" href="#jumping-headlong-into-long-mode" id="jumping-headlong-into-long-mode">Jumping headlong into long mode</a></h1>
<p>We are so close to Rust! Just a little bit of assembly code needed.</p>
<p>Our last task is to update several special registers called 'segment
registers'. Again, we're not using segmentation, but things won't work
unless we set them properly. Once we do, we'll be out of the compatibility
mode and into long mode for real.</p>
<p>Updating the first three registers is easy:</p>
<pre><code class="language-x86asm">; update selectors
mov ax, gdt64.data
mov ss, ax
mov ds, ax
mov es, ax
</code></pre>
<p>Here's a short rundown of these registers:</p>
<ul>
<li><code>ax</code>: This isn't a segment register. It's a sixteen-bit register. Remember
'eax' from our loop accumulator? The 'e' was for 'extended', and it's the
thirty-two bit version of the <code>ax</code> register. The segment registers are
sixteen bit values, so we start off by putting the data part of our GDT
into it, to load into all of the segment registers.</li>
<li><code>ss</code>: The 'stack segment' register. We don't even have a stack yet, that's
how little we're using this. Still needs to be set.</li>
<li><code>ds</code>: the 'data segment' register. This points to the data segment of our
GDT, which is conveniently what we loaded into <code>ax</code>.</li>
<li><code>es</code>: an 'extra segment' register. Not used, still needs to be set.</li>
</ul>
<p>There's one more register which needs to be updated, however: the code segment
register, <code>cs</code>. Should be an easy <code>mov cs, ax</code>, right? Wrong! It's not that easy.
Unfortunately, we can't modify the code segment register ourselves, or bad
things can happen. But we need to change it. So what do we do?</p>
<p>The way to change <code>cs</code> is to execute what's called a 'far jump'. Have you heard
of goto? A jump is just like that; we used one to do our little loop when
setting up paging. A 'far jump' is a jump instruction that goes really far.
That's a little bit simplistic, but the full technical details involve stuff
about memory segmentation, which again, we're not using, so going into them
doesn't matter.</p>
<p>Here's the line to make our far jump:</p>
<pre><code class="language-x86asm">; jump to long mode!
jmp gdt64.code:long_mode_start
</code></pre>
<p>Previously, when we used <code>jne</code> to set up paging, we passed it a label to jump
to. We're doing the same here, but this time, the label is <code>long_mode_start</code>.
We'll define that in a minute. Before we do, we should talk about the other
part of this instruction: <code>gdt64.code:</code>. This is another label, the one to
the code entry of our GDT. This <code>foo:bar</code> syntax is what makes this a long
jump; we're also providing our GDT entry when we jump. When we execute this,
it will then update the code selector register with our entry in the GDT!</p>
<p>I've always loved this part of the boot process. It's very visual for me;
your OS makes a long leap of faith, and comes out the other side realizing that
it has more abilities than it thought! A classic tale of bravery.</p>
<p>But where is this <code>long_mode_start</code> that we're jumping to? Why, defined at
the bottom of our file, of course! Put this at the end of <code>boot.asm</code>:</p>
<pre><code class="language-x86asm">section .text
bits 64
long_mode_start:

    hlt
</code></pre>
<p>A new section! It's another <code>text</code> section, like the rest of our code. But
there's a new <code>bits 64</code> declaration: we're in honest-to-goodness 64-bit mode
now!</p>
<p>Finally, we have our <code>long_mode_start</code> label, and then a humble <code>hlt</code>
instruction to stop execution.</p>
<p>With this set up, we are now officially in long mode! Congrats! Let's do
a small thing to prove it. Modify this code to look like this:</p>
<pre><code class="language-x86asm">long_mode_start:

    mov rax, 0x2f592f412f4b2f4f
    mov qword [0xb8000], rax

    hlt
</code></pre>
<p>We have a new fancy register, <code>rax</code>! Like <code>eax</code> is a 32-bit version of <code>ax</code>,
<code>rax</code> is a 64-bit version of <code>eax</code>. The 'e' in <code>eax</code> stood for 'extended', the
'r' in <code>rax</code> stands for... register. Can't make this stuff up.</p>
<p>Anyway, we put a mystery sixty-four-bit value into <code>rax</code>, and then write it
into <code>0xb8000</code>. If you recall from earlier, that's the upper-left part of the
screen. The <code>qword</code> bit stands for 'quad-word', aka, 64-bit. A word is 16 bits,
a double word is 32 bits, so a quad word is 64 bits.</p>
<p>What does it say? Well, you'll have to run it and find out. 😊</p>
<p>Our next step is going to be a big one: moving to writing Rust code! I hope
you've enjoyed this tour of assembly and legacy computer junk. You've made it
through the toughest bits: getting started is the hardest part.</p>
<h1><a class="header" href="#a-rust-kmain" id="a-rust-kmain">A Rust kmain()</a></h1>
<p>At long last, we're ready to move on to some Rust code! This is ostensibly a
&quot;write a kernel in Rust&quot; tutorial, but we haven't gotten to any Rust code yet.
We're out of the woods with assembly; at least for a while. We'll be writing a
bit more in the future, but for now, let's forget about all of that.</p>
<h1><a class="header" href="#creating-our-first-crate" id="creating-our-first-crate">Creating our first crate</a></h1>
<p>Now that we've got Rust installed, time to write some Rust code! <code>rustup</code> has
also installed Cargo for us, Rust's build tool and package manager. Generate
a new Cargo package like this:</p>
<pre><code class="language-bash">$ cargo init --name intermezzos --lib
</code></pre>
<p>This will create a new package called '<code>intermezzos</code>' in the current directory.
We have some new files. First, <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;intermezzos&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p>This file sets overall configuration for the package. You'll see your
information under <code>authors</code>, Cargo pulls it in from <code>git</code>, if you use it.
Otherwise, you can add it yourself, no big deal.</p>
<p>Next, <code>src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
    }
}
#}</code></pre></pre>
<p>Cargo has generated us a sample test suite. We don't need any of this though;
we won't be doing testing just yet. Let's try building the project:</p>
<pre><code class="language-bash">$ cargo build
   Compiling intermezzos v0.1.0 (file:///path/to/your/kernel)
</code></pre>
<p>After this builds, we have one new file, <code>Cargo.lock</code>. What's in it isn't a big
deal; Cargo uses the file to pin our dependency versions, so its contents are
internal to Cargo.</p>
<p>That said, we need to make two more tweaks. Check out what's in the <code>target</code>
directory:</p>
<pre><code class="language-bash">$ ls target/debug/
build  deps  examples  libintermezzos.rlib  native
</code></pre>
<p>Cargo has generated an <code>.rlib</code>, which is Rust's library format. However, we want
to generate a static library instead. Modify <code>Cargo.toml</code> to have a new section:</p>
<pre><code class="language-toml">[package]
name = &quot;intermezzos&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Steve Klabnik &lt;steve@steveklabnik.com&gt;&quot;]

[lib]
crate-type = [&quot;staticlib&quot;]

[dependencies]
</code></pre>
<p>This <code>crate-type</code> annotation tells Cargo we want to build a static library,
rather than the default <code>rlib</code>. Let's build again:</p>
<pre><code class="language-bash">$ cargo clean
$ cargo build
   Compiling intermezzos v0.1.0 (file:///path/to/your/kernel)
note: link against the following native artifacts when linking against this static library
note: the order and any duplication can be significant on some platforms, and so may need to be preserved
note: library: dl
note: library: pthread
note: library: gcc_s
note: library: c
note: library: m
note: library: rt
note: library: util
</code></pre>
<p>Whew! We get some debugging output. Don't worry about that; we'll be getting
rid of it in a bit. For now, though, we can see that Cargo has built the static
library:</p>
<pre><code class="language-bash">$ ls target/debug/
build  deps  examples  libintermezzos.a  native
</code></pre>
<p>We now have a <code>.a</code> file. This is exactly what we want. Also, make note of this
path: <code>target/debug</code>. That's where Cargo puts output for debugging builds. We
probably should use a release build instead: <code>cargo build --release</code> will
give us that, and put the output in <code>target/release</code>.</p>
<h2><a class="header" href="#creating-a-target" id="creating-a-target">Creating a target</a></h2>
<p>Remember back in the setup chapters, where we talked about <a href="setup.html#Hosts%20&amp;%20Targets">hosts and targets</a>?
We need to do the equivalent for Rust. We <em>could</em> leave things where they are,
but that would cause us problems later. So let's just get it out of the way
now, while we're doing all this other setup.</p>
<p>Create a file named <code>x86_64-unknown-intermezzos-gnu.json</code>, and put this in it:</p>
<pre><code class="language-json">{
	&quot;arch&quot;: &quot;x86_64&quot;,
	&quot;cpu&quot;: &quot;x86-64&quot;,
	&quot;data-layout&quot;: &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;,
	&quot;llvm-target&quot;: &quot;x86_64-unknown-none-gnu&quot;,
	&quot;linker-flavor&quot;: &quot;gcc&quot;,
	&quot;no-compiler-rt&quot;: true,
	&quot;os&quot;: &quot;intermezzos&quot;,
	&quot;target-endian&quot;: &quot;little&quot;,
	&quot;target-pointer-width&quot;: &quot;64&quot;,
	&quot;target-c-int-width&quot;: &quot;32&quot;,
	&quot;features&quot;: &quot;-mmx,-fxsr,-sse,-sse2,+soft-float&quot;,
	&quot;disable-redzone&quot;: true,
	&quot;eliminate-frame-pointer&quot;: false
}
</code></pre>
<p>Unlike <code>gcc</code>, where you have to build a cross-compiler by actually building a
copy of the compiler, Rust lets you cross-compile by creating one of these
&quot;target specifications.&quot; This specification declares all of the various options
that need to be set up for this target to work.</p>
<p>There are two parts of this target specification I'd like to call out in general.
The first is <code>features</code>. We have <code>-mmx,-sse</code>, and such. This controls the assembly
features that we can generate, in other words, we will <em>not</em> be generating MMX or
SSE instructions. These handle floating point, but they're problematic in a kernel.
Basically, we don't <em>need</em> to use them for anything, and they make some things a
lot more difficult. For one thing, we have to explicitly enable SSE support through
some more assembly code, which is annoying, and when we deal with interrupts in a
later chapter, they'll pose some difficulty there, as well. So let's turn them off.
This isn't just a toy kernel thing; Linux also turns off SSE.</p>
<p>The second is <code>disable-redzone</code>. This is a feature of the x86_64 ABI which is
similar: it's useful for application code, but causes problems in the kernel. You
can think of the red zone as a kind of &quot;scratch space,&quot; 128 bytes that's hidden
inside of the stack frame. We don't want any of that in our kernel, so we turn it
off.</p>
<p>The rest of these options aren't particularly interesting. I would tell you to go
look them up in Rust's documentation, but it's sorely lacking at the moment. Maybe
I should stop writing this and go work on that... anyway. I digress.</p>
<p>To use this target specification, we pass <code>--target</code> to Cargo:</p>
<pre><code class="language-bash">$ cargo build --release --target=x86_64-unknown-intermezzos-gnu
   Compiling intermezzos v0.1.0 (file:///path/to/your/kernel)
error: can't find crate for `std` [E0463]
error: aborting due to previous error
error: Could not compile `intermezzos`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Wait, that didn't work? If you think about it, this makes sense: we told Rust that
we wanted to compile our code for intermezzOS, but we haven't compiled a standard
library for it yet! In fact, we don't want a standard library: our operating system
is far from containing the proper features to support it. Instead, we only want
Rust's <code>libcore</code> library. This library contains just the essential stuff, without
all of the fancy features we can't support yet.</p>
<h2><a class="header" href="#building-libcore-with-xargo" id="building-libcore-with-xargo">Building libcore with xargo</a></h2>
<p>So how do we get a copy of <code>libcore</code> for intermezzOS? The answer is <a href="https://github.com/japaric/xargo"><code>xargo</code></a>. It's
a wrapper around Cargo that knows how to read a <code>target.json</code> file and automatically
cross-compile <code>libcore</code>, then set up Cargo to use it.</p>
<p>Let's modify <code>src/lib.rs</code> to get rid of that useless test, and to say we don't want to
use the standard library:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
# #![allow(unused_variables)]
#![no_std]
#fn main() {
#}</code></pre></pre>
<p>That's it, just an empty library with one little annotation. Now we're ready to
build. Well, almost, anyway:</p>
<pre><code class="language-bash">$ cargo install xargo
&lt;snip, let's not include all of this output here. It should build successfully though.&gt;
</code></pre>
<p>In order for <code>xargo</code> to work, it needs a copy of Rust's source code; that's how it
builds a custom <code>libcore</code> for us. Add it with <code>rustup</code>:</p>
<pre><code class="language-bash">$ rustup component add rust-src
</code></pre>
<p>And now let's build:</p>
<pre><code class="language-bash">$ xargo build --release --target=x86_64-unknown-intermezzos-gnu
   Compiling sysroot for x86_64-unknown-intermezzos-gnu
   Compiling core v0.0.0 (file:///home/steve/.xargo/src/libcore)
   Compiling alloc v0.0.0 (file:///home/steve/.xargo/src/liballoc)
   Compiling rustc_unicode v0.0.0 (file:///home/steve/.xargo/src/librustc_unicode)
   Compiling rand v0.0.0 (file:///home/steve/.xargo/src/librand)
   Compiling collections v0.0.0 (file:///home/steve/.xargo/src/libcollections)
   Compiling intermezzos v0.1.0 (file:///home/steve/src/intermezzOS/kernel/chapter_05)
error: language item required, but not found: `panic_fmt`
error: language item required, but not found: `eh_personality`
error: aborting due to 2 previous errors
error: Could not compile `intermezzos`.
</code></pre>
<p>So why'd we get yet another error? For that, we need to understand a Rust
feature, panics.</p>
<h2><a class="header" href="#panic--abort" id="panic--abort">Panic == abort</a></h2>
<p>The specific error we got said &quot;language item required, but not found&quot;. Rust
lets you implement bits of itself through these language items. <code>libcore</code>
defines most of them, but the last two, <code>panic_fmt</code> and <code>eh_personality</code>,
need to be defined by us.</p>
<p>Both of these language items involve a feature of Rust called 'panics.'
Here's a Rust program that panics:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
     panic!(&quot;oh no!&quot;);
}
</code></pre></pre>
<p>When the <code>panic!</code> macro executes, it will stop the current thread from
executing, and unwind the stack. This is something we really don't want
in a kernel. Rust lets us turn this off, though, in our <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.release]
panic = &quot;abort&quot;
</code></pre>
<p>By adding this to our <code>Cargo.toml</code>, Rust will abort when it hits a panic,
rather than unwind. That's good! However, we still need to define those
language items. Modify <code>src/lib.rs</code> to look like this:</p>
<pre><code class="language-rust ignore">#![feature(lang_items)]
#![no_std]

#[lang = &quot;eh_personality&quot;]
extern fn eh_personality() {
}

#[lang = &quot;panic_fmt&quot;]
extern fn rust_begin_panic() -&gt; ! {
    loop {}
}
</code></pre>
<p>Defining language items is a nightly-only feature, so we add the <code>![feature]</code>
flag to turn it on. Then, we define two functions, and annotate them with
the <code>#[lang]</code> attribute to inform Rust that these functions are our language
items. <code>eh_personality()</code> doesn't need to do anything, but <code>rust_begin_panic()</code>
should never return, so we put in an inifinite <code>loop</code>.</p>
<p>Let's try compiling again:</p>
<pre><code class="language-bash">$ xargo build --release --target=x86_64-unknown-intermezzos-gnu
   Compiling intermezzos v0.1.0 (file:///path/to/your/kernel)
$
</code></pre>
<p>Success! We've built some Rust code, cross-compiled to our kernel, and we're
ready to go.</p>
<p>But now, we've got all of our Rust-related stuff in <code>src</code>. But the rest of our
files are still strewn around in our top-level directory. Let's do a little bit
of cleaning up.</p>
<h2><a class="header" href="#some-reorganization" id="some-reorganization">Some reorganization</a></h2>
<p>We have a couple of different ways that we could re-organize the assembly
language. If we were planning on making our OS portable across architectures, a
good solution would be to move it into <code>src/arch/arch_name</code>. That way, we could
have <code>src/arch/x86/</code>, <code>src/arch/x86_64</code>, etc. However, we're not planning on
doing that any time soon. So let's keep it a bit simpler for now:</p>
<pre><code class="language-bash">$ mkdir src/asm
$ mv boot.asm src/asm
$ mv multiboot_header.asm src/asm/
$ mv linker.ld src/asm/
$ mv grub.cfg src/asm/
</code></pre>
<p>Now, we've got everything tucked away nicely. But this has broken our build terribly:</p>
<pre><code class="language-bash">$ make
make: *** No rule to make target 'multiboot_header.asm', needed by 'build/multiboot_header.o'.  Stop.
</code></pre>
<p>Let's fix up our <code>Makefile</code> to work again.</p>
<h2><a class="header" href="#fixing-our-makefile" id="fixing-our-makefile">Fixing our Makefile</a></h2>
<p>The first thing we need to do is fix up the paths:</p>
<pre><code class="language-makefile">build/multiboot_header.o: src/asm/multiboot_header.asm
        mkdir -p build
        nasm -f elf64 src/asm/multiboot_header.asm -o build/multiboot_header.o

build/boot.o: src/asm/boot.asm
        mkdir -p build
        nasm -f elf64 src/asm/boot.asm -o build/boot.o

build/kernel.bin: build/multiboot_header.o build/boot.o src/asm/linker.ld
        ld -n -o build/kernel.bin -T src/asm/linker.ld build/multiboot_header.o build/boot.o

build/os.iso: build/kernel.bin src/asm/grub.cfg
        mkdir -p build/isofiles/boot/grub
        cp src/asm/grub.cfg build/isofiles/boot/grub
        cp build/kernel.bin build/isofiles/boot/
        grub-mkrescue -o build/os.iso build/isofiles
</code></pre>
<p>Here, we've added <code>src/asm/</code> to the start of all of the files that we moved.
This will build:</p>
<pre><code class="language-bash">$ make
mkdir -p build
nasm -f elf64 src/asm/multiboot_header.asm -o build/multiboot_header.o
mkdir -p build
nasm -f elf64 src/asm/boot.asm -o build/boot.o
ld -n -o build/kernel.bin -T src/asm/linker.ld build/multiboot_header.o build/boot.o
$
</code></pre>
<p>Straightforward enough. However, now that we have Cargo, it uses the <code>target</code>
directory, and we're building our assembly into the <code>build</code> directory. Having
two places where our object files go is less than ideal. So let's change it to
output into <code>target</code> instead. Our <code>Makefile</code> will then look like this:</p>
<pre><code class="language-makefile">default: build
        
build: target/kernel.bin

.PHONY: default build run clean

target/multiboot_header.o: src/asm/multiboot_header.asm
        mkdir -p target
        nasm -f elf64 src/asm/multiboot_header.asm -o target/multiboot_header.o

target/boot.o: src/asm/boot.asm
        mkdir -p target
        nasm -f elf64 src/asm/boot.asm -o target/boot.o

target/kernel.bin: target/multiboot_header.o target/boot.o src/asm/linker.ld
        ld -n -o target/kernel.bin -T src/asm/linker.ld target/multiboot_header.o target/boot.o

target/os.iso: target/kernel.bin src/asm/grub.cfg
        mkdir -p target/isofiles/boot/grub
        cp src/asm/grub.cfg target/isofiles/boot/grub
        cp target/kernel.bin target/isofiles/boot/
        grub-mkrescue -o target/os.iso target/isofiles

run: target/os.iso
        qemu-system-x86_64 -cdrom target/os.iso

clean: 
        rm -rf target
</code></pre>
<p>However, that last rule is a bit suspect. It does work just fine, <code>make clean</code>
will do its job. However, Cargo can do this for us, and it's a bit nicer.
Modifying the last rule, we end up with this:</p>
<pre><code class="language-makefile">default: build
        
build: target/kernel.bin

.PHONY: default build run clean

target/multiboot_header.o: src/asm/multiboot_header.asm
        mkdir -p target
        nasm -f elf64 src/asm/multiboot_header.asm -o target/multiboot_header.o

target/boot.o: src/asm/boot.asm
        mkdir -p target
        nasm -f elf64 src/asm/boot.asm -o target/boot.o

target/kernel.bin: target/multiboot_header.o target/boot.o src/asm/linker.ld
        ld -n -o target/kernel.bin -T src/asm/linker.ld target/multiboot_header.o target/boot.o

target/os.iso: target/kernel.bin src/asm/grub.cfg
        mkdir -p target/isofiles/boot/grub
        cp src/asm/grub.cfg target/isofiles/boot/grub
        cp target/kernel.bin target/isofiles/boot/
        grub-mkrescue -o target/os.iso target/isofiles

run: target/os.iso
        qemu-system-x86_64 -cdrom target/os.iso

clean: 
        cargo clean
</code></pre>
<p>Not too bad! We're back where we started. Now, you may notice a bit of
repetition with our two <code>.o</code> file rules. We could make a lot of use of some
more advanced features of Make, and DRY our code up a little. However, it's not
that bad yet, and it's still easy to understand. Makefiles can get very
complicated, so I like to keep them simple. If you're feeling ambitious, maybe
investigating some more features of Make and tweaking this file to your liking
might be an interesting diversion.</p>
<h1><a class="header" href="#hello-from-rust" id="hello-from-rust">Hello from Rust!</a></h1>
<p>Okay, time for the big finale: printing our <code>OKAY</code> from Rust. First, let's
change our <code>Makefile</code> to add the Rust code into our assembly code. We can build
on the steps we did earlier. Here's a new rule to add to the <code>Makefile</code>:</p>
<pre><code class="language-make">cargo:
	xargo build --release --target x86_64-unknown-intermezzos-gnu
</code></pre>
<p>This uses <code>xargo</code> to automatically cross-compile (remember, we're trying to
compile <em>from</em> our OS <em>to</em> intermezzOS) <code>libcore</code> for us. Easy! Let's give it a
try:</p>
<pre><code class="language-bash">$ make cargo
xargo build --release --target x86_64-unknown-intermezzos-gnu
 Downloading https://static.rust-lang.org/dist/2016-09-25/rustc-nightly-src.tar.gz
   Unpacking rustc-nightly-src.tar.gz
   Compiling sysroot for x86_64-unknown-intermezzos-gnu
   Compiling core v0.0.0 (file:///home/steve/.xargo/src/libcore)
   Compiling alloc v0.0.0 (file:///home/steve/.xargo/src/liballoc)
   Compiling rustc_unicode v0.0.0 (file:///home/steve/.xargo/src/librustc_unicode)
   Compiling rand v0.0.0 (file:///home/steve/.xargo/src/librand)
   Compiling collections v0.0.0 (file:///home/steve/.xargo/src/libcollections)
   Compiling intermezzos v0.1.0 (file:///home/steve/src/intermezzOS/kernel/chapter_05)
$
</code></pre>
<p>Success! It should all build properly. There's one more thing I'd like to note
about this makefile: in a strict sense, it will try and rebuild too much. But
watch what happens if we try to build a second time:</p>
<pre><code class="language-bash">$ make cargo
xargo build --release --target x86_64-unknown-intermezzos-gnu
$
</code></pre>
<p>We issued some commands, but didn't actually compile anything. With this
layout, we're letting Cargo worry if stuff needs to be rebuilt. This makes
our Makefile a bit easier to write, and also a bit more reliable. Cargo
knows what it needs to do, let's just trust it to do the right thing.</p>
<p>Now that we have it building, we need to modify the rule that builds the kernel
to include <code>libintermezzos.a</code>:</p>
<pre><code class="language-makefile">target/kernel.bin: target/multiboot_header.o target/boot.o src/asm/linker.ld cargo
        ld -n -o target/kernel.bin -T src/asm/linker.ld target/multiboot_header.o target/boot.o target/x86_64-unknown-intermezzos-gnu/release/libintermezzos.a
</code></pre>
<p>And then we can build:</p>
<pre><code class="language-bash">$ make
mkdir -p target
nasm -f elf64 src/asm/multiboot_header.asm -o target/multiboot_header.o
mkdir -p target
nasm -f elf64 src/asm/boot.asm -o target/boot.o
xargo build --release --target x86_64-unknown-intermezzos-gnu
   Compiling intermezzos v0.1.0 (file:///home/steve/src/intermezzOS/kernel/chapter_05)
ld -n -o target/kernel.bin -T src/asm/linker.ld target/multiboot_header.o target/boot.o target/x86_64-unknown-intermezzos-gnu/release/libintermezzos.a
$
</code></pre>
<p>Hooray! We are now successfully building our assembly code and our Rust code, and then putting them together.</p>
<p>Now, to write our Rust. Add this function to <code>src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern fn kmain() -&gt; ! {

    loop { }
}
#}</code></pre></pre>
<p>This is our main function, which is traditionally called <code>kmain()</code>, for 'kernel
main.' We need to use the <code>#[no_mangle]</code> and <code>pub extern</code> annotations to indicate
that we're going to call this function like we would call a C function. The <code>-&gt; !</code>
indicates that this function never returns. And in fact, it does not return:
the body is an infinite <code>loop</code>.</p>
<p>I'm going to pause here to mention that while I won't totally assume you're a
Rust expert, this is more of an OS tutorial than a Rust tutorial. If anything
about the Rust is confusing, I suggest you read over the <a href="http://doc.rust-lang.org/book">official book</a> to get
an actual introduction to the language. It's tough enough explaining operating
systems as it is without needing to fully explain a language too. But if you're
an experienced programmer, you might be able to get away without it.</p>
<p>Anyway, our <code>kmain()</code> doesn't do anything. But let's try calling it anyway.
Modify <code>src/asm/boot.asm</code>, removing all of the <code>long_mode_start</code> stuff,
and changing the <code>jmp</code> line in <code>start</code> to look like this:</p>
<pre><code class="language-x86asm">    ; jump to long mode!
    jmp gdt64.code:kmain
</code></pre>
<p>Finally, add this line to the top of the file:</p>
<pre><code class="language-x86asm">extern kmain
</code></pre>
<p>This line says that we'll be defining <code>kmain</code> elsewhere: in this case, in Rust!
And so we also change our <code>jmp</code> to jump to <code>kmain</code>.</p>
<p>If you type <code>make run</code>, everything should compile and run, but then not display
anything. We didn't port over the message! Open <code>src/lib.rs</code> and change <code>kmain()</code>
to look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern fn kmain() -&gt; ! {
    unsafe {
        let vga = 0xb8000 as *mut u64;

        *vga = 0x2f592f412f4b2f4f;
    };

    loop { }
}
#}</code></pre></pre>
<p>The first thing you'll notice is the <code>unsafe</code> annotation. Yes, while one of
Rust's defining features is safety, we'll certainly be making use of <code>unsafe</code>
in our kernel. However, we'll be using less than you think. While this is just
printing <code>OKAY</code> to the screen, our intermediate VGA driver will be using the
exact same amount, with a lot more safe code on top.</p>
<p>In this case, the reason we need <code>unsafe</code> is the next two lines: we create a
pointer to <code>0xb8000</code>, and then write some numbers to it. Rust cannot know that
this is safe; if it did, it would have to understand that we are a kernel,
and understand the VGA specification. Having a programming language understand
VGA at that level would be a bit too much. So instead, we have to use unsafe.
Such is life.</p>
<p>However! We are now ready. We've worked really hard for this. Get pumped!!!</p>
<pre><code class="language-bash">$ make run
</code></pre>
<p>If all goes well, this will print <code>OKAY</code> to your screen. But you'll have done
it with Rust! It only took us five chapters to get here!</p>
<p>This is just the beginning, though. At the end of the next chapter, your
main function will look like this, instead:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[macro_export]
# macro_rules! kprintln {
#     ($ctx:ident, $fmt:expr) =&gt; ();
# }
#
#[no_mangle]
pub extern fn kmain() -&gt; ! {
    kprintln!(CONTEXT, &quot;Hello, world!&quot;);

    loop { }
}
#}</code></pre></pre>
<p>But for now, kick back and enjoy what you've done. Congratulations!</p>
<h1><a class="header" href="#appendix-a-troubleshooting" id="appendix-a-troubleshooting">Appendix A: Troubleshooting</a></h1>
<p>In this appendix, we will cover common errors and their solutions for
various chapters of the book.</p>
<h2><a class="header" href="#chapter-3" id="chapter-3">Chapter 3</a></h2>
<p>Here are various solutions to issues you may run into in Chapter 3:</p>
<h3><a class="header" href="#the-ld-tool-does-not-work" id="the-ld-tool-does-not-work">The ld tool does not work</a></h3>
<p>When running the linker tool ld, it may freeze and not produce output. Check the linker file for a syntax error. Make sure comments are closed. You can also run the command with --verbose for more output during linking to help in debugging.</p>
<p>Linux:</p>
<pre><code class="language-bash">$ ld --verbose --nmagic --output kernel.bin --script linker.ld multiboot_header.o boot.o
</code></pre>
<p>Mac OS X:</p>
<pre><code class="language-bash">$ ~/opt/bin/x86_64-pc-elf-ld --verbose --nmagic --output kernel.bin --script linker.ld multiboot_header.o boot.o
</code></pre>
<h3><a class="header" href="#error-no-multiboot-header-found" id="error-no-multiboot-header-found">Error: no multiboot header found</a></h3>
<p>When booting up your kernel, QEMU may print out a message like this:</p>
<pre><code class="language-text">error: no multiboot header found
error: you need to load the kernel first
</code></pre>
<p>This can happen for a number of reasons, but is often caused by typo-ing
something. Double check your code against the examples and make sure that
they’re <em>identical</em>, especially things like magic numbers. They’re easy to
mis-type.</p>
<h3><a class="header" href="#could-not-read-from-cdrom-code-0009" id="could-not-read-from-cdrom-code-0009">Could not read from CDROM (code 0009)</a></h3>
<p>On a system that uses EFI to boot, you may see an error like this:</p>
<pre><code class="language-text">$ qemu-system-x86_64 -cdrom os.iso
Could not read from CDROM (code 0009)
</code></pre>
<p>The solution may be to install the <code>grub-pc-bin</code> package:</p>
<pre><code class="language-bash">$ sudo apt-get install grub-pc-bin
</code></pre>
<p>After the install is complete, you will need to recreate the ISO file
before trying QEMU again:</p>
<pre><code class="language-bash">$ grub-mkrescue -o os.iso isofiles
$ qemu-system-x86_64 -cdrom os.iso
</code></pre>
<h3><a class="header" href="#xorriso--failure--cannot-find-path-efiimg-in-loaded-iso-image" id="xorriso--failure--cannot-find-path-efiimg-in-loaded-iso-image">xorriso : FAILURE : Cannot find path ‘/efi.img’ in loaded ISO image</a></h3>
<p>When building the ISO, you may see a message like this:</p>
<pre><code class="language-text">xorriso : FAILURE : Cannot find path ‘/efi.img’ in loaded ISO image
</code></pre>
<p>The solution may be to install the <code>mtools</code> package:</p>
<pre><code class="language-bash">$ sudo apt-get install mtools
</code></pre>
<h3><a class="header" href="#could-not-initialize-sdlno-available-video-device---exiting" id="could-not-initialize-sdlno-available-video-device---exiting">Could not initialize SDL(No available video device) - exiting</a></h3>
<p>When booting your kernel in QEMU, you may see an error like this:</p>
<pre><code class="language-text">Could not initialize SDL(No available video device) - exiting
</code></pre>
<p>You can pass an extra flag to QEMU to not use SDL, <code>-curses</code>:</p>
<pre><code class="language-bash">$ qemu-system-x86_64 -curses -cdrom os.iso
</code></pre>
<p>Or, try installing SDL and its development headers:</p>
<pre><code class="language-bash">$ sudo apt-get install libsdl2-dev
</code></pre>
<h1><a class="header" href="#numeral-systems" id="numeral-systems">Numeral Systems</a></h1>
<p>In math we use a particular <strong>numeral system</strong> to denote a particular number. A
numeral system is defined by the particular symbols it uses to convey numbers.</p>
<p>Below we'll examine three numeral systems: decimal, binary and hexadecimal.</p>
<h2><a class="header" href="#decimal-system" id="decimal-system">Decimal System</a></h2>
<p>The numeral system you're probably most familiar with is the <strong>decimal system</strong>.
The symbols (or &quot;digits&quot;) used in decimal are: <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>,
<code>6</code>, <code>7</code>, <code>8</code>, and <code>9</code>.</p>
<p>Decimal gets its name from the amount of unique symbols it uses to convey
numbers: ten. It makes sense that we would gravitate to a system with ten
unique symbols. After all, we typically have ten fingers (and ten toes).</p>
<p>The amount of unique symbols a numeral system uses is known as the &quot;base&quot; of that system
(and is less often called a &quot;radix&quot;).</p>
<p>Decimal is also a &quot;positional&quot; numeral system. Once we run out of symbols, we
begin a new &quot;order of magnitude&quot; over with the same symbols. For example, after
<code>9</code> comes <code>10</code>. We recycle the <code>1</code> and <code>0</code> symbols to express that we've cycled
through the number <code>1</code> times. When we reach <code>20</code>, we want to say we've cycled
though <code>2</code> times. We start new cycles at a regular interval - every time we've
cycled through all the symbols of the digit furthest to the left.</p>
<p>If you're familiar with Roman numerals, you know that that system did not work
that way. &quot;Orders of magnitude&quot; don't start and stop at regular intervals.</p>
<h3><a class="header" href="#lets-count" id="lets-count">Let's Count</a></h3>
<p>At the risk of taking things too slow, let's count in decimal the number of <code>|</code>s here:</p>
<p><code>||||||||||||</code></p>
<p>Let's begin with zero and go higher:</p>
<p><code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code> ...</p>
<p>Ok we're at nine, and we've run out of symbols. No worries. We add a <code>1</code> to the
beginning to say we've already gone through one cycle of numbers, and we start
over.</p>
<p>... <code>10</code>, <code>11</code>, <code>12</code></p>
<p>Sorry if that was a bit too easy. You're probably pretty good with the decimal
system already so this wasn't too big of a challenge. But we'll do the same
exercise with other numeral systems to get a better feel for them.</p>
<h3><a class="header" href="#lets-use-math" id="lets-use-math">Let's Use Math</a></h3>
<p>We can summarize what we just said with a math formula:</p>
<p>\[ 1 \cdot 10^1 + 2 \cdot 10^0 = 12 \]</p>
<p>Here we've written out that we've cycled completely through the numbers once
and then gotten through two symbols of the next cycle.</p>
<p>The value <code>120</code> has a <code>0</code> at position zero, a <code>2</code> at position one and a <code>1</code> at position two.</p>
<ul>
<li>
<p>The <code>1</code> at position two means you have counted &quot;one&quot; times &quot;ten&quot; (a.k.a the base)
times all the digits (a.k.a the base) or
\[ 1\cdot base \cdot base = 1 \cdot base^2 = 1 \cdot 10^2 = 100 \]
When writing it as a power of the base, we can see the relation between the
position of the digit and the power of the base.</p>
</li>
<li>
<p>The <code>2</code> at position one means you have counted <em>two times all the digits (a.k.a the base)</em> or
\[ 2 \cdot base = 2 \cdot base^1 =  2 * 10^1 = 20 \]</p>
</li>
<li>
<p>The <code>0</code> at position zero means you have counted <em>zero elements</em> or
\[ 0 = 0 \cdot base^0 = 0 \cdot 10^0 = 0 \cdot 1 = 0 \]</p>
</li>
</ul>
<p>When we add all that up we obtain</p>
<p>\[ 1 \cdot base^2 + 2 \cdot base^1 + 0 \cdot base^0 = 1 \cdot 10^2 +  2 \cdot 10^1 + 0 \cdot 10^0 = 100 + 20 + 0 = 120 \]</p>
<p>Congrats! You've successfully converted a decimal value back into decimal - a
feat that probably seems utterly useless but will come in very handy when we
want to convert from some other numeral system to decimal.</p>
<p>Now we'll examine two new numeral systems. The are positional just like decimal, but
have different bases. We'll examine <strong>binary</strong> with a base of two, and <strong>hexadecimal</strong>
with a base of sixteen.</p>
<h2><a class="header" href="#binary-system" id="binary-system">Binary system</a></h2>
<p>Unlike decimal's base of ten, binary has a base of two. Meaning we only have two
symbols to work with to represent all the numbers: <code>0</code>, <code>1</code>. Say
goodbye to <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, and <code>9</code>. We can't use them.</p>
<p>So when we have the binary number <code>10</code> we don't have the number ten. What we've really
done is counted <em>once through all the digits of the system</em> <code>0</code>, <code>1</code> and
started again. So we have the number two.</p>
<h3><a class="header" href="#lets-count-1" id="lets-count-1">Let's Count</a></h3>
<p>Let's count <code>|</code> again, but this time in binary:</p>
<p><code>|||||||</code></p>
<p>If we were counting in decimal we would use the symbol <code>7</code> to refer to this
number. Let's start at zero:</p>
<p><code>0</code>, <code>1</code> ...</p>
<p>Hopefully you weren't tempted to go to <code>2</code> next! That's right, we've already
made a full round trip, so let's start over.</p>
<p>... <code>10</code>, <code>11</code>, <code>100</code>, <code>101</code>, <code>110</code>, <code>111</code></p>
<p>We've successfully counted to the number seven using binary!</p>
<h3><a class="header" href="#lets-use-math-1" id="lets-use-math-1">Let's Use Math</a></h3>
<p>The binary value <code>100</code> means we have counted <em>one times two (a.k.a the base) times
through all the digits (a.k.a. the base)</em>, which would equal to <code>4</code> in decimal.</p>
<p>\[1 \cdot base^2 + 0 \cdot base^1 + 0 \cdot base^0 = 1 \cdot 2^2 + 0 \cdot 2^1 + 0 \cdot 2^0 = 4 \]</p>
<p>Let's do one more, the binary value <code>1010</code> means we have counted <em>one times two
(a.k.a the base) times two (a.k.a the base) times two (a.k.a the base) digits</em>
and <em>one times two (a.k.a the base) times two (a.k.a the base) digits</em>.</p>
<p>\[ 1 \cdot base^3 + 0 \cdot base ^2 + 1 \cdot base^1 + 0 \cdot base^0 = 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 0 \cdot 2^0 = 8 + 2 = 10\]</p>
<p>Hurray! We've successfully converted binary to decimal!</p>
<h2><a class="header" href="#hexadecimal-system" id="hexadecimal-system">Hexadecimal System</a></h2>
<p>And now we meet hexadecimal with a base of sixteen. Before we begin we have to answer the
question of how we represent sixteen unique digits when we're used to representing only ten.</p>
<p>To represent the digits after <code>9</code> until a new cycle begins we'll use the letters
<code>a</code> through <code>f</code>. This is arbitrary and we could have chosen any other symbol really.
But then again it's all arbitrary. We could, for example, use the symbol <code>}</code> to represent
one, but we chose <code>1</code> instead.</p>
<p>So <code>a</code> in hexadecimal is equivalent to <code>10</code> in decimal, <code>b</code> equal to <code>11</code>, etc.</p>
<p>The value <code>10</code> does exist in hexadecimal. It means, once again, we have counted
<em>through all the digits of the system once</em> and are starting the cycle again.
However, instead of it being ten, it's sixteen. Another way of thinking about
this is <code>10</code> in hexadecimal is equal to <code>16</code> in decimal.</p>
<h3><a class="header" href="#lets-count-2" id="lets-count-2">Let's Count</a></h3>
<p>Once again, let's count <code>|</code>s but this time using hexadecimal notation:</p>
<p><code>||||||||||||||||||||</code></p>
<p>If we were using decimal we would use the symbol <code>20</code> to refer to this number.
Let's start again at zero:</p>
<p><code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code> ...</p>
<p>Don't be tempted to do the decimal thing and use <code>10</code>!</p>
<p>... <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>, <code>10</code>, <code>11</code>, <code>12</code>, <code>13</code>, <code>14</code></p>
<p>Congrats! You've counted to twenty in hexadecimal!</p>
<h3><a class="header" href="#lets-use-math-2" id="lets-use-math-2">Let's Use Math</a></h3>
<p>Let's do the math thing one more time with an exotic hexadecimal value: <code>3e8</code>.
This value means we have counted <em>three times sixteen (a.k.a the base) times all the
digits of the system (a.k.a the base)</em> and <em><code>e</code> times, which is equal to 14 in decimal,
all digits (a.k.a the base)</em> and <em>8 remaining elements</em>.</p>
<p>\[ 3 \cdot base^2 + e \cdot base^1 + 8 \cdot base^0 = 3 \cdot 16^2 + 14 \cdot 16^1 + 8 \cdot 16^0 = 768 + 224 + 8 = 1000 \]</p>
<h2><a class="header" href="#converting-from-decimal-to-another-base" id="converting-from-decimal-to-another-base">Converting From Decimal to Another Base</a></h2>
<p>Until now, we have only converted values from a numeral system with a specific base
to the decimal system. But what if we want to do the opposite?</p>
<p>For this we are going to use the <strong>divison</strong> and <strong>remainders</strong></p>
<p>Let's say we have the value <code>2344</code> and want to convert it into hexadecimal.
We are going to divide the value by the base we want to convert to. The remainder
of this operation will be our first digit (at position zero) and we are going to
repeat this operation with the result of the (integer) division.</p>
<p>\[ \begin{array}
{lcr} 16 &amp; | &amp; 2344
\\ &amp;&amp; 146 &amp; rem &amp; 8
\\ &amp;&amp; 9 &amp; rem &amp; 2
\\ &amp;&amp; 0 &amp; rem &amp; 9
\end{array}
\]</p>
<p>Remember the first remainder is the digit at the first position, position zero!
So the converted number reads from bottom up: <code>928</code>. We can double check that this
is correct by converting the hexadecimal result back into decimal using the power rule.</p>
<p>\[ 9 \cdot 16^2 + 2 \cdot 16^1 + 8 \cdot 16^0 = 2344 \]</p>
<p>Let's do one more hexadecimal number before we try some binary numbers.
The value we are going to convert from decimal to hexadecimal is <code>43981</code>.</p>
<p>\[ \begin{array}
{lcr} 16 &amp; | &amp; 43981
\\ &amp;&amp; 2748 &amp; rem &amp; 13 = d
\\ &amp;&amp; 171 &amp; rem &amp; 12 = c
\\ &amp;&amp; 10 &amp; rem &amp; 11 = b
\\ &amp;&amp; 0 &amp; rem &amp; 10 = a
\end{array}
\]</p>
<p>The decimal value <code>43981</code> corresponds thus to the hexadecimal value <code>abcd</code></p>
<p>Let's try the same for binary numbers now, if we want to convert the decimal value
<code>41</code> to binary:</p>
<p>\[ \begin{array}
{lcr} 2 &amp; | &amp; 41
\\ &amp;&amp; 20 &amp; rem &amp; 1
\\ &amp;&amp; 10 &amp; rem &amp; 0
\\ &amp;&amp; 5 &amp; rem &amp; 0
\\ &amp;&amp; 2 &amp; rem &amp; 1
\\ &amp;&amp; 1 &amp; rem &amp; 0
\\ &amp;&amp; 0 &amp; rem &amp; 1
\end{array}
\]</p>
<p>We get the binary number <code>101001</code>, let's check:</p>
<p>\[ 1 \cdot 2^5 + 0 \cdot 2^4 + 1 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 41 \]</p>
<p>Fantastic, it worked once again!</p>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>In this chapter we have learned there were many numeral systems beside the decimal
system we use in our every day life. We've seen why the hexadecimal system uses the
letters <code>a</code> through <code>f</code> and finally we have learned how to convert back and forth
between any numeral system and the decimal system.</p>
<pre><code class="language-bash">#!/bin/bash
set -e

# First we are going to make sure that you understand this is sort of experimental and we will be compiling stuff.

# by default CONTINUE will be false
CONTINUE=false

echo &quot;&quot;
echo &quot;You are about to download, compile, and install stuff on your computer.&quot;
echo &quot;Please read through the source script to know what is being done.&quot;
echo &quot;Do you want to continue? (y/n)&quot;
read -r response
if [[ $response =~ ^([yY][eE][sS]|[yY])$ ]]; then
  CONTINUE=true
fi

if ! $CONTINUE; then
  # Bail if response is not yes
  echo &quot;Exiting...&quot;
  exit
fi

# check if `brew` is installed
command -v brew &gt;/dev/null 2&gt;&amp;1 || { echo &gt;&amp;2 &quot;It seems you do not have \`brew\` installed. Head on over to http://brew.sh/ to install it.&quot;; exit 1; }

export PREFIX=&quot;$HOME/opt/&quot;
export TARGET=x86_64-pc-elf
export PATH=&quot;$PREFIX/bin:$PATH&quot;

mkdir -p &quot;$HOME/src&quot;
mkdir -p &quot;$PREFIX&quot;

# gmp mpfr libmpc
brew install gmp mpfr libmpc autoconf automake nasm xorriso qemu

# binutils

cd &quot;$HOME/src&quot;

if [ ! -d &quot;binutils-2.27&quot; ]; then
  echo &quot;&quot;
  echo &quot;Installing \`binutils\`&quot;
  echo &quot;&quot;
  curl http://ftp.gnu.org/gnu/binutils/binutils-2.27.tar.gz &gt; binutils-2.27.tar.gz
  tar xfz binutils-2.27.tar.gz
  rm binutils-2.27.tar.gz
  mkdir -p build-binutils
  cd build-binutils
  ../binutils-2.27/configure --target=$TARGET --prefix=&quot;$PREFIX&quot; --with-sysroot --disable-nls --disable-werror
  make
  make install
fi

# gcc
cd &quot;$HOME/src&quot;

if [ ! -d &quot;gcc-6.4.0&quot; ]; then
  echo &quot;&quot;
  echo &quot;Installing \`gcc\`&quot;
  echo &quot;&quot;
  curl -L http://ftpmirror.gnu.org/gcc/gcc-6.4.0/gcc-6.4.0.tar.gz &gt; gcc-6.4.0.tar.gz
  tar jxf gcc-6.4.0.tar.gz
  rm gcc-6.4.0.tar.gz
  mkdir -p build-gcc
  cd build-gcc
  ../gcc-6.4.0/configure --target=&quot;$TARGET&quot; --prefix=&quot;$PREFIX&quot; --disable-nls --enable-languages=c,c++ --without-headers --with-gmp=&quot;$(brew --prefix gmp)&quot; --with-mpfr=&quot;$(brew --prefix mpfr)&quot; --with-mpc=&quot;$(brew --prefix libmpc)&quot;
  make all-gcc
  make all-target-libgcc
  make install-gcc
  make install-target-libgcc
fi

# objconv

cd &quot;$HOME/src&quot;

if [ ! -d &quot;objconv&quot; ]; then
  echo &quot;&quot;
  echo &quot;Installing \`objconv\`&quot;
  echo &quot;&quot;
  curl -L https://www.agner.org/optimize/objconv.zip &gt; objconv.zip
  mkdir -p build-objconv
  unzip objconv.zip -d build-objconv
  cd build-objconv
  unzip source.zip -d src
  g++ -o objconv -O2 src/*.cpp --prefix=&quot;$PREFIX&quot;
  cp objconv &quot;$PREFIX/bin&quot;
fi

# grub

cd &quot;$HOME/src&quot;

if [ ! -d &quot;grub&quot; ]; then
  echo &quot;&quot;
  echo &quot;Installing \`grub\`&quot;
  echo &quot;&quot;
  git clone --depth 1 git://git.savannah.gnu.org/grub.git
  cd grub
  sh autogen.sh
  mkdir -p build-grub
  cd build-grub
  ../configure --disable-werror TARGET_CC=$TARGET-gcc TARGET_OBJCOPY=$TARGET-objcopy \
    TARGET_STRIP=$TARGET-strip TARGET_NM=$TARGET-nm TARGET_RANLIB=$TARGET-ranlib --target=$TARGET --prefix=&quot;$PREFIX&quot;
  make
  make install
fi
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
